!(function(Q) {
  var U = window.webpackHotUpdate
  window.webpackHotUpdate = function(Q, F) {
    !(function(Q, U) {
      if (!C[Q] || !S[Q]) return
      for (var F in ((S[Q] = !1), U)) Object.prototype.hasOwnProperty.call(U, F) && (d[F] = U[F])
      0 == --o && 0 === L && r()
    })(Q, F),
      U && U(Q, F)
  }
  var F,
    B = !0,
    n = '07e5a985c5636c671741',
    e = 1e4,
    s = {},
    t = [],
    l = []
  function c(Q) {
    var U = Z[Q]
    if (!U) return V
    var B = function(B) {
        return (
          U.hot.active
            ? (Z[B] ? -1 === Z[B].parents.indexOf(Q) && Z[B].parents.push(Q) : ((t = [Q]), (F = B)),
              -1 === U.children.indexOf(B) && U.children.push(B))
            : (console.warn('[HMR] unexpected require(' + B + ') from disposed module ' + Q),
              (t = [])),
          V(B)
        )
      },
      n = function(Q) {
        return {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return V[Q]
          },
          set: function(U) {
            V[Q] = U
          }
        }
      }
    for (var e in V)
      Object.prototype.hasOwnProperty.call(V, e) &&
        'e' !== e &&
        't' !== e &&
        Object.defineProperty(B, e, n(e))
    return (
      (B.e = function(Q) {
        return (
          'ready' === x && b('prepare'),
          L++,
          V.e(Q).then(U, function(Q) {
            throw (U(), Q)
          })
        )
        function U() {
          L--, 'prepare' === x && (u[Q] || y(Q), 0 === L && 0 === o && r())
        }
      }),
      (B.t = function(Q, U) {
        return 1 & U && (Q = B(Q)), V.t(Q, -2 & U)
      }),
      B
    )
  }
  function g(Q) {
    var U = {
      _acceptedDependencies: {},
      _declinedDependencies: {},
      _selfAccepted: !1,
      _selfDeclined: !1,
      _disposeHandlers: [],
      _main: F !== Q,
      active: !0,
      accept: function(Q, F) {
        if (void 0 === Q) U._selfAccepted = !0
        else if ('function' == typeof Q) U._selfAccepted = Q
        else if ('object' == typeof Q)
          for (var B = 0; B < Q.length; B++) U._acceptedDependencies[Q[B]] = F || function() {}
        else U._acceptedDependencies[Q] = F || function() {}
      },
      decline: function(Q) {
        if (void 0 === Q) U._selfDeclined = !0
        else if ('object' == typeof Q)
          for (var F = 0; F < Q.length; F++) U._declinedDependencies[Q[F]] = !0
        else U._declinedDependencies[Q] = !0
      },
      dispose: function(Q) {
        U._disposeHandlers.push(Q)
      },
      addDisposeHandler: function(Q) {
        U._disposeHandlers.push(Q)
      },
      removeDisposeHandler: function(Q) {
        var F = U._disposeHandlers.indexOf(Q)
        F >= 0 && U._disposeHandlers.splice(F, 1)
      },
      check: G,
      apply: R,
      status: function(Q) {
        if (!Q) return x
        i.push(Q)
      },
      addStatusHandler: function(Q) {
        i.push(Q)
      },
      removeStatusHandler: function(Q) {
        var U = i.indexOf(Q)
        U >= 0 && i.splice(U, 1)
      },
      data: s[Q]
    }
    return (F = void 0), U
  }
  var i = [],
    x = 'idle'
  function b(Q) {
    x = Q
    for (var U = 0; U < i.length; U++) i[U].call(null, Q)
  }
  var I,
    d,
    a,
    o = 0,
    L = 0,
    u = {},
    S = {},
    C = {}
  function E(Q) {
    return +Q + '' === Q ? +Q : Q
  }
  function G(Q) {
    if ('idle' !== x) throw new Error('check() is only allowed in idle status')
    return (
      (B = Q),
      b('check'),
      ((U = e),
      (U = U || 1e4),
      new Promise(function(Q, F) {
        if ('undefined' == typeof XMLHttpRequest) return F(new Error('No browser support'))
        try {
          var B = new XMLHttpRequest(),
            e = V.p + '' + n + '.hot-update.json'
          B.open('GET', e, !0), (B.timeout = U), B.send(null)
        } catch (Q) {
          return F(Q)
        }
        B.onreadystatechange = function() {
          if (4 === B.readyState)
            if (0 === B.status) F(new Error('Manifest request to ' + e + ' timed out.'))
            else if (404 === B.status) Q()
            else if (200 !== B.status && 304 !== B.status)
              F(new Error('Manifest request to ' + e + ' failed.'))
            else {
              try {
                var U = JSON.parse(B.responseText)
              } catch (Q) {
                return void F(Q)
              }
              Q(U)
            }
        }
      })).then(function(Q) {
        if (!Q) return b('idle'), null
        ;(S = {}), (u = {}), (C = Q.c), (a = Q.h), b('prepare')
        var U = new Promise(function(Q, U) {
          I = { resolve: Q, reject: U }
        })
        d = {}
        return y(1), 'prepare' === x && 0 === L && 0 === o && r(), U
      })
    )
    var U
  }
  function y(Q) {
    C[Q]
      ? ((S[Q] = !0),
        o++,
        (function(Q) {
          var U = document.createElement('script')
          ;(U.charset = 'utf-8'),
            (U.src = V.p + '' + Q + '.' + n + '.hot-update.js'),
            document.head.appendChild(U)
        })(Q))
      : (u[Q] = !0)
  }
  function r() {
    b('ready')
    var Q = I
    if (((I = null), Q))
      if (B)
        Promise.resolve()
          .then(function() {
            return R(B)
          })
          .then(
            function(U) {
              Q.resolve(U)
            },
            function(U) {
              Q.reject(U)
            }
          )
      else {
        var U = []
        for (var F in d) Object.prototype.hasOwnProperty.call(d, F) && U.push(E(F))
        Q.resolve(U)
      }
  }
  function R(U) {
    if ('ready' !== x) throw new Error('apply() is only allowed in ready status')
    var F, B, e, l, c
    function g(Q) {
      for (
        var U = [Q],
          F = {},
          B = U.map(function(Q) {
            return { chain: [Q], id: Q }
          });
        B.length > 0;

      ) {
        var n = B.pop(),
          e = n.id,
          s = n.chain
        if ((l = Z[e]) && !l.hot._selfAccepted) {
          if (l.hot._selfDeclined) return { type: 'self-declined', chain: s, moduleId: e }
          if (l.hot._main) return { type: 'unaccepted', chain: s, moduleId: e }
          for (var t = 0; t < l.parents.length; t++) {
            var c = l.parents[t],
              g = Z[c]
            if (g) {
              if (g.hot._declinedDependencies[e])
                return { type: 'declined', chain: s.concat([c]), moduleId: e, parentId: c }
              ;-1 === U.indexOf(c) &&
                (g.hot._acceptedDependencies[e]
                  ? (F[c] || (F[c] = []), i(F[c], [e]))
                  : (delete F[c], U.push(c), B.push({ chain: s.concat([c]), id: c })))
            }
          }
        }
      }
      return { type: 'accepted', moduleId: Q, outdatedModules: U, outdatedDependencies: F }
    }
    function i(Q, U) {
      for (var F = 0; F < U.length; F++) {
        var B = U[F]
        ;-1 === Q.indexOf(B) && Q.push(B)
      }
    }
    U = U || {}
    var I = {},
      o = [],
      L = {},
      u = function() {
        console.warn('[HMR] unexpected require(' + G.moduleId + ') to disposed module')
      }
    for (var S in d)
      if (Object.prototype.hasOwnProperty.call(d, S)) {
        var G
        c = E(S)
        var y = !1,
          r = !1,
          R = !1,
          m = ''
        switch (
          ((G = d[S] ? g(c) : { type: 'disposed', moduleId: S }).chain &&
            (m = '\nUpdate propagation: ' + G.chain.join(' -> ')),
          G.type)
        ) {
          case 'self-declined':
            U.onDeclined && U.onDeclined(G),
              U.ignoreDeclined ||
                (y = new Error('Aborted because of self decline: ' + G.moduleId + m))
            break
          case 'declined':
            U.onDeclined && U.onDeclined(G),
              U.ignoreDeclined ||
                (y = new Error(
                  'Aborted because of declined dependency: ' + G.moduleId + ' in ' + G.parentId + m
                ))
            break
          case 'unaccepted':
            U.onUnaccepted && U.onUnaccepted(G),
              U.ignoreUnaccepted || (y = new Error('Aborted because ' + c + ' is not accepted' + m))
            break
          case 'accepted':
            U.onAccepted && U.onAccepted(G), (r = !0)
            break
          case 'disposed':
            U.onDisposed && U.onDisposed(G), (R = !0)
            break
          default:
            throw new Error('Unexception type ' + G.type)
        }
        if (y) return b('abort'), Promise.reject(y)
        if (r)
          for (c in ((L[c] = d[c]), i(o, G.outdatedModules), G.outdatedDependencies))
            Object.prototype.hasOwnProperty.call(G.outdatedDependencies, c) &&
              (I[c] || (I[c] = []), i(I[c], G.outdatedDependencies[c]))
        R && (i(o, [G.moduleId]), (L[c] = u))
      }
    var N,
      p = []
    for (B = 0; B < o.length; B++)
      (c = o[B]),
        Z[c] &&
          Z[c].hot._selfAccepted &&
          L[c] !== u &&
          p.push({ module: c, errorHandler: Z[c].hot._selfAccepted })
    b('dispose'),
      Object.keys(C).forEach(function(Q) {
        !1 === C[Q] &&
          (function(Q) {
            delete installedChunks[Q]
          })(Q)
      })
    for (var W, D, A = o.slice(); A.length > 0; )
      if (((c = A.pop()), (l = Z[c]))) {
        var h = {},
          X = l.hot._disposeHandlers
        for (e = 0; e < X.length; e++) (F = X[e])(h)
        for (
          s[c] = h, l.hot.active = !1, delete Z[c], delete I[c], e = 0;
          e < l.children.length;
          e++
        ) {
          var H = Z[l.children[e]]
          H && (N = H.parents.indexOf(c)) >= 0 && H.parents.splice(N, 1)
        }
      }
    for (c in I)
      if (Object.prototype.hasOwnProperty.call(I, c) && (l = Z[c]))
        for (D = I[c], e = 0; e < D.length; e++)
          (W = D[e]), (N = l.children.indexOf(W)) >= 0 && l.children.splice(N, 1)
    for (c in (b('apply'), (n = a), L)) Object.prototype.hasOwnProperty.call(L, c) && (Q[c] = L[c])
    var v = null
    for (c in I)
      if (Object.prototype.hasOwnProperty.call(I, c) && (l = Z[c])) {
        D = I[c]
        var J = []
        for (B = 0; B < D.length; B++)
          if (((W = D[B]), (F = l.hot._acceptedDependencies[W]))) {
            if (-1 !== J.indexOf(F)) continue
            J.push(F)
          }
        for (B = 0; B < J.length; B++) {
          F = J[B]
          try {
            F(D)
          } catch (Q) {
            U.onErrored &&
              U.onErrored({ type: 'accept-errored', moduleId: c, dependencyId: D[B], error: Q }),
              U.ignoreErrored || v || (v = Q)
          }
        }
      }
    for (B = 0; B < p.length; B++) {
      var M = p[B]
      ;(c = M.module), (t = [c])
      try {
        V(c)
      } catch (Q) {
        if ('function' == typeof M.errorHandler)
          try {
            M.errorHandler(Q)
          } catch (F) {
            U.onErrored &&
              U.onErrored({
                type: 'self-accept-error-handler-errored',
                moduleId: c,
                error: F,
                originalError: Q
              }),
              U.ignoreErrored || v || (v = F),
              v || (v = Q)
          }
        else
          U.onErrored && U.onErrored({ type: 'self-accept-errored', moduleId: c, error: Q }),
            U.ignoreErrored || v || (v = Q)
      }
    }
    return v
      ? (b('fail'), Promise.reject(v))
      : (b('idle'),
        new Promise(function(Q) {
          Q(o)
        }))
  }
  var Z = {}
  function V(U) {
    if (Z[U]) return Z[U].exports
    var F = (Z[U] = {
      i: U,
      l: !1,
      exports: {},
      hot: g(U),
      parents: ((l = t), (t = []), l),
      children: []
    })
    return Q[U].call(F.exports, F, F.exports, c(U)), (F.l = !0), F.exports
  }
  ;(V.m = Q),
    (V.c = Z),
    (V.d = function(Q, U, F) {
      V.o(Q, U) || Object.defineProperty(Q, U, { enumerable: !0, get: F })
    }),
    (V.r = function(Q) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(Q, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(Q, '__esModule', { value: !0 })
    }),
    (V.t = function(Q, U) {
      if ((1 & U && (Q = V(Q)), 8 & U)) return Q
      if (4 & U && 'object' == typeof Q && Q && Q.__esModule) return Q
      var F = Object.create(null)
      if (
        (V.r(F),
        Object.defineProperty(F, 'default', { enumerable: !0, value: Q }),
        2 & U && 'string' != typeof Q)
      )
        for (var B in Q)
          V.d(
            F,
            B,
            function(U) {
              return Q[U]
            }.bind(null, B)
          )
      return F
    }),
    (V.n = function(Q) {
      var U =
        Q && Q.__esModule
          ? function() {
              return Q.default
            }
          : function() {
              return Q
            }
      return V.d(U, 'a', U), U
    }),
    (V.o = function(Q, U) {
      return Object.prototype.hasOwnProperty.call(Q, U)
    }),
    (V.p = ''),
    (V.h = function() {
      return n
    }),
    c(3)((V.s = 3))
})([
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "\n// EXTERNAL MODULE: ./src/polyfills.js\nvar polyfills = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./src/pointers.ts\n/**\n * Utilites for working with multiple pointer events\n */\nfunction findEventIndex(pointers, event) {\n    var i = pointers.length;\n    while (i--) {\n        if (pointers[i].pointerId === event.pointerId) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction addPointer(pointers, event) {\n    var i;\n    // Add touches if applicable\n    if (event.touches) {\n        i = 0;\n        for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {\n            var touch = _a[_i];\n            touch.pointerId = i++;\n            addPointer(pointers, touch);\n        }\n        return;\n    }\n    i = findEventIndex(pointers, event);\n    // Update if already present\n    if (i > -1) {\n        pointers.splice(i, 1);\n    }\n    pointers.push(event);\n}\nfunction removePointer(pointers, event) {\n    // Add touches if applicable\n    if (event.touches) {\n        // Remove all touches\n        while (pointers.length) {\n            pointers.pop();\n        }\n        return;\n    }\n    var i = findEventIndex(pointers, event);\n    if (i > -1) {\n        pointers.splice(i, 1);\n    }\n}\n/**\n * Calculates a center point between\n * the given pointer events, for panning\n * with multiple pointers.\n */\nfunction getMiddle(pointers) {\n    // Copy to avoid changing by reference\n    pointers = pointers.slice(0);\n    var event1 = pointers.pop();\n    var event2;\n    while ((event2 = pointers.pop())) {\n        event1 = {\n            clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,\n            clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY\n        };\n    }\n    return event1;\n}\n/**\n * Calculates the distance between two points\n * for pinch zooming.\n * Limits to the first 2\n */\nfunction getDistance(pointers) {\n    if (pointers.length < 2) {\n        return 0;\n    }\n    var event1 = pointers[0];\n    var event2 = pointers[1];\n    return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) +\n        Math.pow(Math.abs(event2.clientY - event1.clientY), 2));\n}\n\n// CONCATENATED MODULE: ./src/events.ts\nvar events;\nif (typeof window.PointerEvent === 'function') {\n    events = {\n        down: 'pointerdown',\n        move: 'pointermove',\n        up: 'pointerup pointerleave pointercancel'\n    };\n}\nelse if (typeof window.TouchEvent === 'function') {\n    events = {\n        down: 'touchstart',\n        move: 'touchmove',\n        up: 'touchend touchcancel'\n    };\n}\nelse {\n    events = {\n        down: 'mousedown',\n        move: 'mousemove',\n        up: 'mouseup mouseleave'\n    };\n}\nfunction onPointer(event, elem, handler, eventOpts) {\n    events[event].split(' ').forEach(function (name) {\n        ;\n        elem.addEventListener(name, handler, eventOpts);\n    });\n}\nfunction destroyPointer(event, elem, handler) {\n    events[event].split(' ').forEach(function (name) {\n        ;\n        elem.removeEventListener(name, handler);\n    });\n}\n\n// CONCATENATED MODULE: ./src/css.ts\n/**\n * Proper prefixing for cross-browser compatibility\n */\nvar divStyle = document.createElement('div').style;\nvar prefixes = ['webkit', 'moz', 'ms'];\nvar prefixCache = {};\nfunction getPrefixedName(name) {\n    if (prefixCache[name]) {\n        return prefixCache[name];\n    }\n    if (name in divStyle) {\n        return (prefixCache[name] = name);\n    }\n    var capName = name[0].toUpperCase() + name.slice(1);\n    var i = prefixes.length;\n    while (i--) {\n        var prefixedName = \"\" + prefixes[i] + capName;\n        if (prefixedName in divStyle) {\n            return (prefixCache[name] = prefixedName);\n        }\n    }\n}\n/**\n * Gets a style value expected to be a number\n */\nfunction getCSSNum(name, style) {\n    return parseFloat(style[getPrefixedName(name)]) || 0;\n}\nfunction getBoxStyle(elem, name, style) {\n    if (style === void 0) { style = window.getComputedStyle(elem); }\n    // Support: FF 68+\n    // Firefox requires specificity for border\n    var suffix = name === 'border' ? 'Width' : '';\n    return {\n        left: getCSSNum(name + \"Left\" + suffix, style),\n        right: getCSSNum(name + \"Right\" + suffix, style),\n        top: getCSSNum(name + \"Top\" + suffix, style),\n        bottom: getCSSNum(name + \"Bottom\" + suffix, style)\n    };\n}\n/**\n * Set a style using the properly prefixed name\n */\nfunction setStyle(elem, name, value) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    elem.style[getPrefixedName(name)] = value;\n}\n/**\n * Constructs the transition from panzoom options\n * and takes care of prefixing the transition and transform\n */\nfunction setTransition(elem, options) {\n    var transition = getPrefixedName('transition');\n    var transform = getPrefixedName('transform');\n    setStyle(elem, transition, transform + \" \" + options.duration + \"ms \" + options.easing);\n}\n/**\n * Set the transform using the proper prefix\n */\nfunction setTransform(elem, _a, options) {\n    var x = _a.x, y = _a.y, scale = _a.scale;\n    if (options === void 0) { options = {}; }\n    if (typeof options.animate === 'boolean') {\n        if (options.animate) {\n            setTransition(elem, options);\n        }\n        else {\n            setStyle(elem, 'transition', 'none');\n        }\n    }\n    requestAnimationFrame(function () {\n        setStyle(elem, 'transform', \"scale(\" + scale + \") translate(\" + x + \"px, \" + y + \"px)\");\n    });\n}\n/**\n * Dimensions used in containment and focal point zooming\n */\nfunction getDimensions(elem) {\n    var parent = elem.parentElement;\n    var style = window.getComputedStyle(elem);\n    var parentStyle = window.getComputedStyle(parent);\n    var rectElem = elem.getBoundingClientRect();\n    var rectParent = parent.getBoundingClientRect();\n    return {\n        elem: {\n            style: style,\n            width: rectElem.width,\n            height: rectElem.height,\n            top: rectElem.top,\n            bottom: rectElem.bottom,\n            left: rectElem.left,\n            right: rectElem.right,\n            margin: getBoxStyle(elem, 'margin', style),\n            border: getBoxStyle(elem, 'border', style)\n        },\n        parent: {\n            style: parentStyle,\n            width: rectParent.width,\n            height: rectParent.height,\n            top: rectParent.top,\n            bottom: rectParent.bottom,\n            left: rectParent.left,\n            right: rectParent.right,\n            padding: getBoxStyle(parent, 'padding', parentStyle),\n            border: getBoxStyle(parent, 'border', parentStyle)\n        }\n    };\n}\n\n// CONCATENATED MODULE: ./src/isAttached.ts\n/**\n * Determine if an element is attached to the DOM\n * Panzoom requires this so events work properly\n */\nfunction isAttached(elem) {\n    var doc = elem.ownerDocument;\n    var parent = elem.parentElement;\n    return doc && parent && doc.nodeType === 9 && parent.nodeType === 1 && doc.contains(parent);\n}\n\n// CONCATENATED MODULE: ./src/isExcluded.ts\nfunction isExcluded(elem, options) {\n    for (var cur = elem; cur != null; cur = cur.parentElement) {\n        if (cur.classList.contains(options.excludeClass) || options.exclude.indexOf(cur) > -1) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// CONCATENATED MODULE: ./src/isSVGElement.ts\n/**\n * Determine if an element is SVG by checking the namespace\n * Exception: the <svg> element itself should be treated like HTML\n */\nvar rsvg = /^http:[\\w\\.\\/]+svg$/;\nfunction isSVGElement(elem) {\n    return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';\n}\n\n// CONCATENATED MODULE: ./src/shallowClone.ts\nfunction shallowClone(obj) {\n    var clone = {};\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            clone[key] = obj[key];\n        }\n    }\n    return clone;\n}\n\n// CONCATENATED MODULE: ./src/panzoom.ts\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/**\n * Panzoom for panning and zooming elements using CSS transforms\n * https://github.com/timmywil/panzoom\n *\n * Copyright Timmy Willison and other contributors\n * Released under the MIT license\n * https://github.com/timmywil/panzoom/blob/master/MIT-License.txt\n *\n */\n\n\n\n\n\n\n\n\nvar defaultOptions = {\n    animate: false,\n    cursor: 'move',\n    disablePan: false,\n    disableZoom: false,\n    disableXAxis: false,\n    disableYAxis: false,\n    duration: 200,\n    easing: 'ease-in-out',\n    exclude: [],\n    excludeClass: 'panzoom-exclude',\n    handleStartEvent: function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n    },\n    maxScale: 4,\n    minScale: 0.125,\n    overflow: 'hidden',\n    panOnlyWhenZoomed: false,\n    relative: false,\n    setTransform: setTransform,\n    startX: 0,\n    startY: 0,\n    startScale: 1,\n    step: 0.3\n};\nfunction Panzoom(elem, options) {\n    if (!elem) {\n        throw new Error('Panzoom requires an element as an argument');\n    }\n    if (elem.nodeType !== 1) {\n        throw new Error('Panzoom requires an element with a nodeType of 1');\n    }\n    if (!isAttached(elem)) {\n        throw new Error('Panzoom should be called on elements that have been attached to the DOM');\n    }\n    options = __assign(__assign({}, defaultOptions), options);\n    var isSVG = isSVGElement(elem);\n    // Set overflow on the parent\n    var parent = elem.parentElement;\n    parent.style.overflow = options.overflow;\n    parent.style.userSelect = 'none';\n    // This is important for mobile to\n    // prevent scrolling while panning\n    parent.style.touchAction = 'none';\n    // Set some default styles on the panzoom element\n    elem.style.cursor = options.cursor;\n    elem.style.userSelect = 'none';\n    elem.style.touchAction = 'none';\n    // The default for HTML is '50% 50%'\n    // The default for SVG is '0 0'\n    // SVG can't be changed in IE\n    setStyle(elem, 'transformOrigin', typeof options.origin === 'string' ? options.origin : isSVG ? '0 0' : '50% 50%');\n    function setOptions(opts) {\n        if (opts === void 0) { opts = {}; }\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                options[key] = opts[key];\n            }\n        }\n        // Handle option side-effects\n        if (opts.hasOwnProperty('cursor')) {\n            elem.style.cursor = opts.cursor;\n        }\n        if (opts.hasOwnProperty('overflow')) {\n            parent.style.overflow = opts.overflow;\n        }\n        if (opts.hasOwnProperty('minScale') ||\n            opts.hasOwnProperty('maxScale') ||\n            opts.hasOwnProperty('contain')) {\n            setMinMax();\n        }\n    }\n    var x = 0;\n    var y = 0;\n    var scale = 1;\n    var isPanning = false;\n    zoom(options.startScale, { animate: false });\n    // Wait for scale to update\n    // for accurate dimensions\n    // to constrain initial values\n    setTimeout(function () {\n        setMinMax();\n        pan(options.startX, options.startY, { animate: false });\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function trigger(eventName, detail, opts) {\n        if (opts.silent) {\n            return;\n        }\n        var event = new CustomEvent(eventName, { detail: detail });\n        elem.dispatchEvent(event);\n    }\n    function setTransformWithEvent(eventName, opts) {\n        var value = { x: x, y: y, scale: scale };\n        opts.setTransform(elem, value, opts);\n        trigger(eventName, value, opts);\n        trigger('panzoomchange', value, opts);\n        return value;\n    }\n    function setMinMax() {\n        if (options.contain) {\n            var dims = getDimensions(elem);\n            var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;\n            var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;\n            var elemWidth = dims.elem.width / scale;\n            var elemHeight = dims.elem.height / scale;\n            var elemScaledWidth = parentWidth / elemWidth;\n            var elemScaledHeight = parentHeight / elemHeight;\n            if (options.contain === 'inside') {\n                options.maxScale = Math.min(elemScaledWidth, elemScaledHeight);\n            }\n            else if (options.contain === 'outside') {\n                options.minScale = Math.max(elemScaledWidth, elemScaledHeight);\n            }\n        }\n    }\n    function constrainXY(toX, toY, toScale, panOptions) {\n        var opts = __assign(__assign({}, options), panOptions);\n        var result = { x: x, y: y, opts: opts };\n        if (!opts.force && (opts.disablePan || (opts.panOnlyWhenZoomed && scale === opts.startScale))) {\n            return result;\n        }\n        toX = parseFloat(toX);\n        toY = parseFloat(toY);\n        if (!opts.disableXAxis) {\n            result.x = (opts.relative ? x : 0) + toX;\n        }\n        if (!opts.disableYAxis) {\n            result.y = (opts.relative ? y : 0) + toY;\n        }\n        if (opts.contain === 'inside') {\n            var dims = getDimensions(elem);\n            result.x = Math.max(-dims.elem.margin.left - dims.parent.padding.left, Math.min(dims.parent.width -\n                dims.elem.width / toScale -\n                dims.parent.padding.left -\n                dims.elem.margin.left -\n                dims.parent.border.left -\n                dims.parent.border.right, result.x));\n            result.y = Math.max(-dims.elem.margin.top - dims.parent.padding.top, Math.min(dims.parent.height -\n                dims.elem.height / toScale -\n                dims.parent.padding.top -\n                dims.elem.margin.top -\n                dims.parent.border.top -\n                dims.parent.border.bottom, result.y));\n        }\n        else if (opts.contain === 'outside') {\n            var dims = getDimensions(elem);\n            var realWidth = dims.elem.width / scale;\n            var realHeight = dims.elem.height / scale;\n            var scaledWidth = realWidth * toScale;\n            var scaledHeight = realHeight * toScale;\n            var diffHorizontal = (scaledWidth - realWidth) / 2;\n            var diffVertical = (scaledHeight - realHeight) / 2;\n            var minX = (-(scaledWidth - dims.parent.width) -\n                dims.parent.padding.left -\n                dims.parent.border.left -\n                dims.parent.border.right +\n                diffHorizontal) /\n                toScale;\n            var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;\n            result.x = Math.max(Math.min(result.x, maxX), minX);\n            var minY = (-(scaledHeight - dims.parent.height) -\n                dims.parent.padding.top -\n                dims.parent.border.top -\n                dims.parent.border.bottom +\n                diffVertical) /\n                toScale;\n            var maxY = (diffVertical - dims.parent.padding.top) / toScale;\n            result.y = Math.max(Math.min(result.y, maxY), minY);\n        }\n        return result;\n    }\n    function constrainScale(toScale, zoomOptions) {\n        var opts = __assign(__assign({}, options), zoomOptions);\n        var result = { scale: scale, opts: opts };\n        if (!opts.force && opts.disableZoom) {\n            return result;\n        }\n        result.scale = Math.min(Math.max(toScale, opts.minScale), opts.maxScale);\n        return result;\n    }\n    function pan(toX, toY, panOptions) {\n        var result = constrainXY(toX, toY, scale, panOptions);\n        var opts = result.opts;\n        x = result.x;\n        y = result.y;\n        return setTransformWithEvent('panzoompan', opts);\n    }\n    function zoom(toScale, zoomOptions) {\n        var result = constrainScale(toScale, zoomOptions);\n        var opts = result.opts;\n        if (!opts.force && opts.disableZoom) {\n            return;\n        }\n        toScale = result.scale;\n        var toX = x;\n        var toY = y;\n        if (opts.focal) {\n            // The difference between the point after the scale and the point before the scale\n            // plus the current translation after the scale\n            // neutralized to no scale (as the transform scale will apply to the translation)\n            var focal = opts.focal;\n            toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;\n            toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;\n        }\n        var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });\n        x = panResult.x;\n        y = panResult.y;\n        scale = toScale;\n        return setTransformWithEvent('panzoomzoom', opts);\n    }\n    function zoomInOut(isIn, zoomOptions) {\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);\n        return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);\n    }\n    function zoomIn(zoomOptions) {\n        return zoomInOut(true, zoomOptions);\n    }\n    function zoomOut(zoomOptions) {\n        return zoomInOut(false, zoomOptions);\n    }\n    function zoomToPoint(toScale, point, zoomOptions) {\n        var dims = getDimensions(elem);\n        // Instead of thinking of operating on the panzoom element,\n        // think of operating on the area inside the panzoom\n        // element's parent\n        // Subtract padding and border\n        var effectiveArea = {\n            width: dims.parent.width -\n                dims.parent.padding.left -\n                dims.parent.padding.right -\n                dims.parent.border.left -\n                dims.parent.border.right,\n            height: dims.parent.height -\n                dims.parent.padding.top -\n                dims.parent.padding.bottom -\n                dims.parent.border.top -\n                dims.parent.border.bottom\n        };\n        // Adjust the clientX/clientY to ignore the area\n        // outside the effective area\n        var clientX = point.clientX -\n            dims.parent.left -\n            dims.parent.padding.left -\n            dims.parent.border.left -\n            dims.elem.margin.left;\n        var clientY = point.clientY -\n            dims.parent.top -\n            dims.parent.padding.top -\n            dims.parent.border.top -\n            dims.elem.margin.top;\n        // Adjust the clientX/clientY for HTML elements,\n        // because they have a transform-origin of 50% 50%\n        if (!isSVG) {\n            clientX -= dims.elem.width / scale / 2;\n            clientY -= dims.elem.height / scale / 2;\n        }\n        // Convert the mouse point from it's position over the\n        // effective area before the scale to the position\n        // over the effective area after the scale.\n        var focal = {\n            x: (clientX / effectiveArea.width) * (effectiveArea.width * toScale),\n            y: (clientY / effectiveArea.height) * (effectiveArea.height * toScale)\n        };\n        return zoom(toScale, __assign(__assign({}, zoomOptions), { focal: focal, animate: false }));\n    }\n    function zoomWithWheel(event, zoomOptions) {\n        // Need to prevent the default here\n        // or it conflicts with regular page scroll\n        event.preventDefault();\n        var opts = __assign(__assign({}, options), zoomOptions);\n        // Normalize to deltaX in case shift modifier is used on Mac\n        var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;\n        var wheel = delta < 0 ? 1 : -1;\n        var toScale = constrainScale(scale * Math.exp((wheel * opts.step) / 3), opts).scale;\n        return zoomToPoint(toScale, event, opts);\n    }\n    function reset(resetOptions) {\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), resetOptions);\n        scale = constrainScale(opts.startScale, opts).scale;\n        var panResult = constrainXY(opts.startX, opts.startY, scale, opts);\n        x = panResult.x;\n        y = panResult.y;\n        return setTransformWithEvent('panzoomreset', opts);\n    }\n    var origX;\n    var origY;\n    var startClientX;\n    var startClientY;\n    var startScale;\n    var startDistance;\n    var pointers = [];\n    function handleDown(event) {\n        // Don't handle this event if the target is excluded\n        if (isExcluded(event.target, options)) {\n            return;\n        }\n        addPointer(pointers, event);\n        isPanning = true;\n        options.handleStartEvent(event);\n        origX = x;\n        origY = y;\n        trigger('panzoomstart', { x: x, y: y, scale: scale }, options);\n        // This works whether there are multiple\n        // pointers or not\n        var point = getMiddle(pointers);\n        startClientX = point.clientX;\n        startClientY = point.clientY;\n        startScale = scale;\n        startDistance = getDistance(pointers);\n    }\n    function move(event) {\n        if (!isPanning ||\n            origX === undefined ||\n            origY === undefined ||\n            startClientX === undefined ||\n            startClientY === undefined) {\n            return;\n        }\n        addPointer(pointers, event);\n        var current = getMiddle(pointers);\n        if (pointers.length > 1) {\n            // Use the distance between the first 2 pointers\n            // to determine the current scale\n            var diff = getDistance(pointers) - startDistance;\n            var toScale = constrainScale((diff * options.step) / 80 + startScale).scale;\n            zoomToPoint(toScale, current);\n        }\n        pan(origX + (current.clientX - startClientX) / scale, origY + (current.clientY - startClientY) / scale, {\n            animate: false\n        });\n    }\n    function handleUp(event) {\n        // Don't call panzoomend when panning with 2 touches\n        // until both touches end\n        if (pointers.length === 1) {\n            trigger('panzoomend', { x: x, y: y, scale: scale }, options);\n        }\n        // Note: don't remove all pointers\n        // Can restart without having to reinitiate all of them\n        // Remove the pointer regardless of the isPanning state\n        removePointer(pointers, event);\n        if (!isPanning) {\n            return;\n        }\n        isPanning = false;\n        origX = origY = startClientX = startClientY = undefined;\n    }\n    if (!options.disablePan) {\n        onPointer('down', elem, handleDown);\n        onPointer('move', document, move, { passive: true });\n        onPointer('up', document, handleUp, { passive: true });\n    }\n    function destroy() {\n        destroyPointer('down', elem, handleDown);\n        destroyPointer('move', document, move);\n        destroyPointer('up', document, handleUp);\n    }\n    return {\n        destroy: destroy,\n        getPan: function () { return ({ x: x, y: y }); },\n        getScale: function () { return scale; },\n        getOptions: function () { return shallowClone(options); },\n        pan: pan,\n        reset: reset,\n        setOptions: setOptions,\n        setStyle: function (name, value) { return setStyle(elem, name, value); },\n        zoom: zoom,\n        zoomIn: zoomIn,\n        zoomOut: zoomOut,\n        zoomToPoint: zoomToPoint,\n        zoomWithWheel: zoomWithWheel\n    };\n}\nPanzoom.defaultOptions = defaultOptions;\n/* harmony default export */ var panzoom = __webpack_exports__[\"a\"] = (Panzoom);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9pbnRlcnMudHM/ZDA1OCIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLnRzPzA1ZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy50cz84MTQzIiwid2VicGFjazovLy8uL3NyYy9pc0F0dGFjaGVkLnRzP2EwM2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lzRXhjbHVkZWQudHM/NTQzMiIsIndlYnBhY2s6Ly8vLi9zcmMvaXNTVkdFbGVtZW50LnRzPzQ2MjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWxsb3dDbG9uZS50cz9lNDc2Iiwid2VicGFjazovLy8uL3NyYy9wYW56b29tLnRzP2I4ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7R0FFRztBQUVILFNBQVMsY0FBYyxDQUFDLFFBQXdCLEVBQUUsS0FBbUI7SUFDbkUsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU07SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNWLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLLENBQUMsU0FBUyxFQUFFO1lBQzdDLE9BQU8sQ0FBQztTQUNUO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFTSxTQUFTLFVBQVUsQ0FBQyxRQUF3QixFQUFFLEtBQW1CO0lBQ3RFLElBQUksQ0FBQztJQUNMLDRCQUE0QjtJQUM1QixJQUFLLEtBQWEsQ0FBQyxPQUFPLEVBQUU7UUFDMUIsQ0FBQyxHQUFHLENBQUM7UUFDTCxLQUFvQixVQUFzQixFQUF0QixLQUFDLEtBQWEsQ0FBQyxPQUFPLEVBQXRCLGNBQXNCLEVBQXRCLElBQXNCLEVBQUU7WUFBdkMsSUFBTSxLQUFLO1lBQ2QsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDckIsVUFBVSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUM7U0FDNUI7UUFDRCxPQUFNO0tBQ1A7SUFDRCxDQUFDLEdBQUcsY0FBYyxDQUFDLFFB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QztRQUN0QyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUM7SUFDMUMsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPO1FBQ1AsTUFBTSxFQUFFLGNBQU0sUUFBQyxFQUFFLENBQUMsS0FBRSxDQUFDLEtBQUUsQ0FBQyxFQUFWLENBQVU7UUFDeEIsUUFBUSxFQUFFLGNBQU0sWUFBSyxFQUFMLENBQUs7UUFDckIsVUFBVSxFQUFFLGNBQU0sbUJBQVksQ0FBQyxPQUFPLENBQUMsRUFBckIsQ0FBcUI7UUFDdkMsR0FBRztRQUNILEtBQUs7UUFDTCxVQUFVO1FBQ1YsUUFBUSxFQUFFLFVBQUMsSUFBWSxFQUFFLEtBQWEsSUFBSyxlQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsRUFBM0IsQ0FBMkI7UUFDdEUsSUFBSTtRQUNKLE1BQU07UUFDTixPQUFPO1FBQ1AsV0FBVztRQUNYLGFBQWE7S0FDZDtBQUNILENBQUM7QUFFRCxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWM7QUFFeEIsOEVBQU8iLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0ZXMgZm9yIHdvcmtpbmcgd2l0aCBtdWx0aXBsZSBwb2ludGVyIGV2ZW50c1xuICovXG5cbmZ1bmN0aW9uIGZpbmRFdmVudEluZGV4KHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSwgZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICBsZXQgaSA9IHBvaW50ZXJzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZXZlbnQucG9pbnRlcklkKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvaW50ZXIocG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdLCBldmVudDogUG9pbnRlckV2ZW50KSB7XG4gIGxldCBpXG4gIC8vIEFkZCB0b3VjaGVzIGlmIGFwcGxpY2FibGVcbiAgaWYgKChldmVudCBhcyBhbnkpLnRvdWNoZXMpIHtcbiAgICBpID0gMFxuICAgIGZvciAoY29uc3QgdG91Y2ggb2YgKGV2ZW50IGFzIGFueSkudG91Y2hlcykge1xuICAgICAgdG91Y2gucG9pbnRlcklkID0gaSsrXG4gICAgICBhZGRQb2ludGVyKHBvaW50ZXJzLCB0b3VjaClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgaSA9IGZpbmRFdmVudEluZGV4KHBvaW50ZXJzLCBldmVudClcbiAgLy8gVXBkYXRlIGlmIGFscmVhZHkgcHJlc2VudFxuICBpZiAoaSA+IC0xKSB7XG4gICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpXG4gIH1cbiAgcG9pbnRlcnMucHVzaChldmVudClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIocG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdLCBldmVudDogUG9pbnRlckV2ZW50KSB7XG4gIC8vIEFkZCB0b3VjaGVzIGlmIGFwcGxpY2FibGVcbiAgaWYgKChldmVudCBhcyBhbnkpLnRvdWNoZXMpIHtcbiAgICAvLyBSZW1vdmUgYWxsIHRvdWNoZXNcbiAgICB3aGlsZSAocG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICBwb2ludGVycy5wb3AoKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBpID0gZmluZEV2ZW50SW5kZXgocG9pbnRlcnMsIGV2ZW50KVxuICBpZiAoaSA+IC0xKSB7XG4gICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgY2VudGVyIHBvaW50IGJldHdlZW5cbiAqIHRoZSBnaXZlbiBwb2ludGVyIGV2ZW50cywgZm9yIHBhbm5pbmdcbiAqIHdpdGggbXVsdGlwbGUgcG9pbnRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWRkbGUocG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdKSB7XG4gIC8vIENvcHkgdG8gYXZvaWQgY2hhbmdpbmcgYnkgcmVmZXJlbmNlXG4gIHBvaW50ZXJzID0gcG9pbnRlcnMuc2xpY2UoMClcbiAgbGV0IGV2ZW50MTogUGljazxQb2ludGVyRXZlbnQsICdjbGllbnRYJyB8ICdjbGllbnRZJz4gPSBwb2ludGVycy5wb3AoKVxuICBsZXQgZXZlbnQyOiBQb2ludGVyRXZlbnRcbiAgd2hpbGUgKChldmVudDIgPSBwb2ludGVycy5wb3AoKSkpIHtcbiAgICBldmVudDEgPSB7XG4gICAgICBjbGllbnRYOiAoZXZlbnQyLmNsaWVudFggLSBldmVudDEuY2xpZW50WCkgLyAyICsgZXZlbnQxLmNsaWVudFgsXG4gICAgICBjbGllbnRZOiAoZXZlbnQyLmNsaWVudFkgLSBldmVudDEuY2xpZW50WSkgLyAyICsgZXZlbnQxLmNsaWVudFlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50MVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogZm9yIHBpbmNoIHpvb21pbmcuXG4gKiBMaW1pdHMgdG8gdGhlIGZpcnN0IDJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSkge1xuICBpZiAocG9pbnRlcnMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiAwXG4gIH1cbiAgY29uc3QgZXZlbnQxID0gcG9pbnRlcnNbMF1cbiAgY29uc3QgZXZlbnQyID0gcG9pbnRlcnNbMV1cbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhNYXRoLmFicyhldmVudDIuY2xpZW50WCAtIGV2ZW50MS5jbGllbnRYKSwgMikgK1xuICAgICAgTWF0aC5wb3coTWF0aC5hYnMoZXZlbnQyLmNsaWVudFkgLSBldmVudDEuY2xpZW50WSksIDIpXG4gIClcbn1cbiIsImxldCBldmVudHM6IHsgZG93bjogc3RyaW5nOyBtb3ZlOiBzdHJpbmc7IHVwOiBzdHJpbmcgfVxuaWYgKHR5cGVvZiAod2luZG93IGFzIGFueSkuUG9pbnRlckV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIGV2ZW50cyA9IHtcbiAgICBkb3duOiAncG9pbnRlcmRvd24nLFxuICAgIG1vdmU6ICdwb2ludGVybW92ZScsXG4gICAgdXA6ICdwb2ludGVydXAgcG9pbnRlcmxlYXZlIHBvaW50ZXJjYW5jZWwnXG4gIH1cbn0gZWxzZSBpZiAodHlwZW9mICh3aW5kb3cgYXMgYW55KS5Ub3VjaEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIGV2ZW50cyA9IHtcbiAgICBkb3duOiAndG91Y2hzdGFydCcsXG4gICAgbW92ZTogJ3RvdWNobW92ZScsXG4gICAgdXA6ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCdcbiAgfVxufSBlbHNlIHtcbiAgZXZlbnRzID0ge1xuICAgIGRvd246ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHVwOiAnbW91c2V1cCBtb3VzZWxlYXZlJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblBvaW50ZXIoXG4gIGV2ZW50OiAnZG93bicgfCAnbW92ZScgfCAndXAnLFxuICBlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQgfCBEb2N1bWVudCxcbiAgaGFuZGxlcjogKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHZvaWQsXG4gIGV2ZW50T3B0cz86IGFueVxuKSB7XG4gIGV2ZW50c1tldmVudF0uc3BsaXQoJyAnKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgOyhlbGVtIGFzIEhUTUxFbGVtZW50KS5hZGRFdmVudExpc3RlbmVyPFxuICAgICAgJ3BvaW50ZXJkb3duJyB8ICdwb2ludGVybW92ZScgfCAncG9pbnRlcnVwJyB8ICdwb2ludGVybGVhdmUnIHwgJ3BvaW50ZXJjYW5jZWwnXG4gICAgPihuYW1lIGFzIGFueSwgaGFuZGxlciwgZXZlbnRPcHRzKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveVBvaW50ZXIoXG4gIGV2ZW50OiAnZG93bicgfCAnbW92ZScgfCAndXAnLFxuICBlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQgfCBEb2N1bWVudCxcbiAgaGFuZGxlcjogKGV2ZW50OiBQb2ludGVyRXZlbnQpID0+IHZvaWRcbikge1xuICBldmVudHNbZXZlbnRdLnNwbGl0KCcgJykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIDsoZWxlbSBhcyBIVE1MRWxlbWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcjxcbiAgICAgICdwb2ludGVyZG93bicgfCAncG9pbnRlcm1vdmUnIHwgJ3BvaW50ZXJ1cCcgfCAncG9pbnRlcmxlYXZlJyB8ICdwb2ludGVyY2FuY2VsJ1xuICAgID4obmFtZSBhcyBhbnksIGhhbmRsZXIpXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBDdXJyZW50VmFsdWVzLCBQYW56b29tT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogUHJvcGVyIHByZWZpeGluZyBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gKi9cbmNvbnN0IGRpdlN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGVcbmNvbnN0IHByZWZpeGVzID0gWyd3ZWJraXQnLCAnbW96JywgJ21zJ11cbmNvbnN0IHByZWZpeENhY2hlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge31cbmZ1bmN0aW9uIGdldFByZWZpeGVkTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHByZWZpeENhY2hlW25hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeENhY2hlW25hbWVdXG4gIH1cbiAgaWYgKG5hbWUgaW4gZGl2U3R5bGUpIHtcbiAgICByZXR1cm4gKHByZWZpeENhY2hlW25hbWVdID0gbmFtZSlcbiAgfVxuICBjb25zdCBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKVxuICBsZXQgaSA9IHByZWZpeGVzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3QgcHJlZml4ZWROYW1lID0gYCR7cHJlZml4ZXNbaV19JHtjYXBOYW1lfWBcbiAgICBpZiAocHJlZml4ZWROYW1lIGluIGRpdlN0eWxlKSB7XG4gICAgICByZXR1cm4gKHByZWZpeENhY2hlW25hbWVdID0gcHJlZml4ZWROYW1lKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgYSBzdHlsZSB2YWx1ZSBleHBlY3RlZCB0byBiZSBhIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q1NTTnVtKG5hbWU6IHN0cmluZywgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24pIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVbZ2V0UHJlZml4ZWROYW1lKG5hbWUpIGFzIGFueV0pIHx8IDBcbn1cblxuZnVuY3Rpb24gZ2V0Qm94U3R5bGUoXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCxcbiAgbmFtZTogc3RyaW5nLFxuICBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pXG4pIHtcbiAgLy8gU3VwcG9ydDogRkYgNjgrXG4gIC8vIEZpcmVmb3ggcmVxdWlyZXMgc3BlY2lmaWNpdHkgZm9yIGJvcmRlclxuICBjb25zdCBzdWZmaXggPSBuYW1lID09PSAnYm9yZGVyJyA/ICdXaWR0aCcgOiAnJ1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGdldENTU051bShgJHtuYW1lfUxlZnQke3N1ZmZpeH1gLCBzdHlsZSksXG4gICAgcmlnaHQ6IGdldENTU051bShgJHtuYW1lfVJpZ2h0JHtzdWZmaXh9YCwgc3R5bGUpLFxuICAgIHRvcDogZ2V0Q1NTTnVtKGAke25hbWV9VG9wJHtzdWZmaXh9YCwgc3R5bGUpLFxuICAgIGJvdHRvbTogZ2V0Q1NTTnVtKGAke25hbWV9Qm90dG9tJHtzdWZmaXh9YCwgc3R5bGUpXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBzdHlsZSB1c2luZyB0aGUgcHJvcGVybHkgcHJlZml4ZWQgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgZWxlbS5zdHlsZVtnZXRQcmVmaXhlZE5hbWUobmFtZSkgYXMgYW55XSA9IHZhbHVlXG59XG5cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgdHJhbnNpdGlvbiBmcm9tIHBhbnpvb20gb3B0aW9uc1xuICogYW5kIHRha2VzIGNhcmUgb2YgcHJlZml4aW5nIHRoZSB0cmFuc2l0aW9uIGFuZCB0cmFuc2Zvcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBvcHRpb25zOiBQYW56b29tT3B0aW9ucykge1xuICBjb25zdCB0cmFuc2l0aW9uID0gZ2V0UHJlZml4ZWROYW1lKCd0cmFuc2l0aW9uJylcbiAgY29uc3QgdHJhbnNmb3JtID0gZ2V0UHJlZml4ZWROYW1lKCd0cmFuc2Zvcm0nKVxuICBzZXRTdHlsZShlbGVtLCB0cmFuc2l0aW9uLCBgJHt0cmFuc2Zvcm19ICR7b3B0aW9ucy5kdXJhdGlvbn1tcyAke29wdGlvbnMuZWFzaW5nfWApXG59XG5cbi8qKlxuICogU2V0IHRoZSB0cmFuc2Zvcm0gdXNpbmcgdGhlIHByb3BlciBwcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICB7IHgsIHksIHNjYWxlIH06IEN1cnJlbnRWYWx1ZXMsXG4gIG9wdGlvbnM6IFBhbnpvb21PcHRpb25zID0ge31cbikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuYW5pbWF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgc2V0VHJhbnNpdGlvbihlbGVtLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdHlsZShlbGVtLCAndHJhbnNpdGlvbicsICdub25lJylcbiAgICB9XG4gIH1cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBzZXRTdHlsZShlbGVtLCAndHJhbnNmb3JtJywgYHNjYWxlKCR7c2NhbGV9KSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYClcbiAgfSlcbn1cblxuLyoqXG4gKiBEaW1lbnNpb25zIHVzZWQgaW4gY29udGFpbm1lbnQgYW5kIGZvY2FsIHBvaW50IHpvb21pbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50RWxlbWVudFxuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pXG4gIGNvbnN0IHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KVxuICBjb25zdCByZWN0RWxlbSA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgcmVjdFBhcmVudCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gIHJldHVybiB7XG4gICAgZWxlbToge1xuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aDogcmVjdEVsZW0ud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3RFbGVtLmhlaWdodCxcbiAgICAgIHRvcDogcmVjdEVsZW0udG9wLFxuICAgICAgYm90dG9tOiByZWN0RWxlbS5ib3R0b20sXG4gICAgICBsZWZ0OiByZWN0RWxlbS5sZWZ0LFxuICAgICAgcmlnaHQ6IHJlY3RFbGVtLnJpZ2h0LFxuICAgICAgbWFyZ2luOiBnZXRCb3hTdHlsZShlbGVtLCAnbWFyZ2luJywgc3R5bGUpLFxuICAgICAgYm9yZGVyOiBnZXRCb3hTdHlsZShlbGVtLCAnYm9yZGVyJywgc3R5bGUpXG4gICAgfSxcbiAgICBwYXJlbnQ6IHtcbiAgICAgIHN0eWxlOiBwYXJlbnRTdHlsZSxcbiAgICAgIHdpZHRoOiByZWN0UGFyZW50LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0UGFyZW50LmhlaWdodCxcbiAgICAgIHRvcDogcmVjdFBhcmVudC50b3AsXG4gICAgICBib3R0b206IHJlY3RQYXJlbnQuYm90dG9tLFxuICAgICAgbGVmdDogcmVjdFBhcmVudC5sZWZ0LFxuICAgICAgcmlnaHQ6IHJlY3RQYXJlbnQucmlnaHQsXG4gICAgICBwYWRkaW5nOiBnZXRCb3hTdHlsZShwYXJlbnQsICdwYWRkaW5nJywgcGFyZW50U3R5bGUpLFxuICAgICAgYm9yZGVyOiBnZXRCb3hTdHlsZShwYXJlbnQsICdib3JkZXInLCBwYXJlbnRTdHlsZSlcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTVxuICogUGFuem9vbSByZXF1aXJlcyB0aGlzIHNvIGV2ZW50cyB3b3JrIHByb3Blcmx5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXR0YWNoZWQoZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KSB7XG4gIGNvbnN0IGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudFxuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudEVsZW1lbnRcbiAgcmV0dXJuIGRvYyAmJiBwYXJlbnQgJiYgZG9jLm5vZGVUeXBlID09PSA5ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiBkb2MuY29udGFpbnMocGFyZW50KVxufVxuIiwiaW1wb3J0IHsgUGFuem9vbU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0V4Y2x1ZGVkKGVsZW06IEVsZW1lbnQsIG9wdGlvbnM6IFBhbnpvb21PcHRpb25zKSB7XG4gIGZvciAobGV0IGN1ciA9IGVsZW07IGN1ciAhPSBudWxsOyBjdXIgPSBjdXIucGFyZW50RWxlbWVudCkge1xuICAgIGlmIChjdXIuY2xhc3NMaXN0LmNvbnRhaW5zKG9wdGlvbnMuZXhjbHVkZUNsYXNzKSB8fCBvcHRpb25zLmV4Y2x1ZGUuaW5kZXhPZihjdXIpID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBTVkcgYnkgY2hlY2tpbmcgdGhlIG5hbWVzcGFjZVxuICogRXhjZXB0aW9uOiB0aGUgPHN2Zz4gZWxlbWVudCBpdHNlbGYgc2hvdWxkIGJlIHRyZWF0ZWQgbGlrZSBIVE1MXG4gKi9cbmNvbnN0IHJzdmcgPSAvXmh0dHA6W1xcd1xcLlxcL10rc3ZnJC9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpIHtcbiAgcmV0dXJuIHJzdmcudGVzdChlbGVtLm5hbWVzcGFjZVVSSSkgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJ1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iajogYW55KSB7XG4gIGNvbnN0IGNsb25lOiBhbnkgPSB7fVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNsb25lW2tleV0gPSBvYmpba2V5XVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cbiIsIi8qKlxuICogUGFuem9vbSBmb3IgcGFubmluZyBhbmQgem9vbWluZyBlbGVtZW50cyB1c2luZyBDU1MgdHJhbnNmb3Jtc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3RpbW15d2lsL3Bhbnpvb21cbiAqXG4gKiBDb3B5cmlnaHQgVGltbXkgV2lsbGlzb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGltbXl3aWwvcGFuem9vbS9ibG9iL21hc3Rlci9NSVQtTGljZW5zZS50eHRcbiAqXG4gKi9cbmltcG9ydCAnLi9wb2x5ZmlsbHMnXG5cbmltcG9ydCB7IFBhbk9wdGlvbnMsIFBhbnpvb21FdmVudCwgUGFuem9vbU9iamVjdCwgUGFuem9vbU9wdGlvbnMsIFpvb21PcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IGFkZFBvaW50ZXIsIGdldERpc3RhbmNlLCBnZXRNaWRkbGUsIHJlbW92ZVBvaW50ZXIgfSBmcm9tICcuL3BvaW50ZXJzJ1xuaW1wb3J0IHsgZGVzdHJveVBvaW50ZXIsIG9uUG9pbnRlciB9IGZyb20gJy4vZXZlbnRzJ1xuaW1wb3J0IHsgZ2V0RGltZW5zaW9ucywgc2V0U3R5bGUsIHNldFRyYW5zZm9ybSB9IGZyb20gJy4vY3NzJ1xuXG5pbXBvcnQgaXNBdHRhY2hlZCBmcm9tICcuL2lzQXR0YWNoZWQnXG5pbXBvcnQgaXNFeGNsdWRlZCBmcm9tICcuL2lzRXhjbHVkZWQnXG5pbXBvcnQgaXNTVkdFbGVtZW50IGZyb20gJy4vaXNTVkdFbGVtZW50J1xuaW1wb3J0IHNoYWxsb3dDbG9uZSBmcm9tICcuL3NoYWxsb3dDbG9uZSdcblxuY29uc3QgZGVmYXVsdE9wdGlvbnM6IFBhbnpvb21PcHRpb25zID0ge1xuICBhbmltYXRlOiBmYWxzZSxcbiAgY3Vyc29yOiAnbW92ZScsXG4gIGRpc2FibGVQYW46IGZhbHNlLFxuICBkaXNhYmxlWm9vbTogZmFsc2UsXG4gIGRpc2FibGVYQXhpczogZmFsc2UsXG4gIGRpc2FibGVZQXhpczogZmFsc2UsXG4gIGR1cmF0aW9uOiAyMDAsXG4gIGVhc2luZzogJ2Vhc2UtaW4tb3V0JyxcbiAgZXhjbHVkZTogW10sXG4gIGV4Y2x1ZGVDbGFzczogJ3Bhbnpvb20tZXhjbHVkZScsXG4gIGhhbmRsZVN0YXJ0RXZlbnQ6IChlOiBFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgfSxcbiAgbWF4U2NhbGU6IDQsXG4gIG1pblNjYWxlOiAwLjEyNSxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBwYW5Pbmx5V2hlblpvb21lZDogZmFsc2UsXG4gIHJlbGF0aXZlOiBmYWxzZSxcbiAgc2V0VHJhbnNmb3JtLFxuICBzdGFydFg6IDAsXG4gIHN0YXJ0WTogMCxcbiAgc3RhcnRTY2FsZTogMSxcbiAgc3RlcDogMC4zXG59XG5cbmZ1bmN0aW9uIFBhbnpvb20oXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCxcbiAgb3B0aW9ucz86IE9taXQ8UGFuem9vbU9wdGlvbnMsICdmb3JjZSc+XG4pOiBQYW56b29tT2JqZWN0IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYW56b29tIHJlcXVpcmVzIGFuIGVsZW1lbnQgYXMgYW4gYXJndW1lbnQnKVxuICB9XG4gIGlmIChlbGVtLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYW56b29tIHJlcXVpcmVzIGFuIGVsZW1lbnQgd2l0aCBhIG5vZGVUeXBlIG9mIDEnKVxuICB9XG4gIGlmICghaXNBdHRhY2hlZChlbGVtKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFuem9vbSBzaG91bGQgYmUgY2FsbGVkIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGF0dGFjaGVkIHRvIHRoZSBET00nKVxuICB9XG5cbiAgb3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH1cblxuICBjb25zdCBpc1NWRyA9IGlzU1ZHRWxlbWVudChlbGVtKVxuXG4gIC8vIFNldCBvdmVyZmxvdyBvbiB0aGUgcGFyZW50XG4gIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50RWxlbWVudFxuICBwYXJlbnQuc3R5bGUub3ZlcmZsb3cgPSBvcHRpb25zLm92ZXJmbG93XG4gIHBhcmVudC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnXG4gIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBtb2JpbGUgdG9cbiAgLy8gcHJldmVudCBzY3JvbGxpbmcgd2hpbGUgcGFubmluZ1xuICBwYXJlbnQuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSdcblxuICAvLyBTZXQgc29tZSBkZWZhdWx0IHN0eWxlcyBvbiB0aGUgcGFuem9vbSBlbGVtZW50XG4gIGVsZW0uc3R5bGUuY3Vyc29yID0gb3B0aW9ucy5jdXJzb3JcbiAgZWxlbS5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnXG4gIGVsZW0uc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSdcbiAgLy8gVGhlIGRlZmF1bHQgZm9yIEhUTUwgaXMgJzUwJSA1MCUnXG4gIC8vIFRoZSBkZWZhdWx0IGZvciBTVkcgaXMgJzAgMCdcbiAgLy8gU1ZHIGNhbid0IGJlIGNoYW5nZWQgaW4gSUVcbiAgc2V0U3R5bGUoXG4gICAgZWxlbSxcbiAgICAndHJhbnNmb3JtT3JpZ2luJyxcbiAgICB0eXBlb2Ygb3B0aW9ucy5vcmlnaW4gPT09ICdzdHJpbmcnID8gb3B0aW9ucy5vcmlnaW4gOiBpc1NWRyA/ICcwIDAnIDogJzUwJSA1MCUnXG4gIClcblxuICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHM6IE9taXQ8UGFuem9vbU9wdGlvbnMsICdmb3JjZSc+ID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzKSB7XG4gICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgb3B0aW9uIHNpZGUtZWZmZWN0c1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdjdXJzb3InKSkge1xuICAgICAgZWxlbS5zdHlsZS5jdXJzb3IgPSBvcHRzLmN1cnNvclxuICAgIH1cbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnb3ZlcmZsb3cnKSkge1xuICAgICAgcGFyZW50LnN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBvcHRzLmhhc093blByb3BlcnR5KCdtaW5TY2FsZScpIHx8XG4gICAgICBvcHRzLmhhc093blByb3BlcnR5KCdtYXhTY2FsZScpIHx8XG4gICAgICBvcHRzLmhhc093blByb3BlcnR5KCdjb250YWluJylcbiAgICApIHtcbiAgICAgIHNldE1pbk1heCgpXG4gICAgfVxuICB9XG5cbiAgbGV0IHggPSAwXG4gIGxldCB5ID0gMFxuICBsZXQgc2NhbGUgPSAxXG4gIGxldCBpc1Bhbm5pbmcgPSBmYWxzZVxuICB6b29tKG9wdGlvbnMuc3RhcnRTY2FsZSwgeyBhbmltYXRlOiBmYWxzZSB9KVxuICAvLyBXYWl0IGZvciBzY2FsZSB0byB1cGRhdGVcbiAgLy8gZm9yIGFjY3VyYXRlIGRpbWVuc2lvbnNcbiAgLy8gdG8gY29uc3RyYWluIGluaXRpYWwgdmFsdWVzXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNldE1pbk1heCgpXG4gICAgcGFuKG9wdGlvbnMuc3RhcnRYLCBvcHRpb25zLnN0YXJ0WSwgeyBhbmltYXRlOiBmYWxzZSB9KVxuICB9KVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnROYW1lOiBQYW56b29tRXZlbnQsIGRldGFpbDogYW55LCBvcHRzOiBQYW56b29tT3B0aW9ucykge1xuICAgIGlmIChvcHRzLnNpbGVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwgfSlcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoZXZlbnROYW1lOiBQYW56b29tRXZlbnQsIG9wdHM6IFBhbnpvb21PcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSB7IHgsIHksIHNjYWxlIH1cbiAgICBvcHRzLnNldFRyYW5zZm9ybShlbGVtLCB2YWx1ZSwgb3B0cylcbiAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgdmFsdWUsIG9wdHMpXG4gICAgdHJpZ2dlcigncGFuem9vbWNoYW5nZScsIHZhbHVlLCBvcHRzKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWluTWF4KCkge1xuICAgIGlmIChvcHRpb25zLmNvbnRhaW4pIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IGRpbXMucGFyZW50LndpZHRoIC0gZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLSBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHRcbiAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IGRpbXMucGFyZW50LmhlaWdodCAtIGRpbXMucGFyZW50LmJvcmRlci50b3AgLSBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tXG4gICAgICBjb25zdCBlbGVtV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbUhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbVNjYWxlZFdpZHRoID0gcGFyZW50V2lkdGggLyBlbGVtV2lkdGhcbiAgICAgIGNvbnN0IGVsZW1TY2FsZWRIZWlnaHQgPSBwYXJlbnRIZWlnaHQgLyBlbGVtSGVpZ2h0XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgICBvcHRpb25zLm1heFNjYWxlID0gTWF0aC5taW4oZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnRhaW4gPT09ICdvdXRzaWRlJykge1xuICAgICAgICBvcHRpb25zLm1pblNjYWxlID0gTWF0aC5tYXgoZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpblhZKFxuICAgIHRvWDogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvWTogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwYW5PcHRpb25zPzogUGFuT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi5wYW5PcHRpb25zIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IHgsIHksIG9wdHMgfVxuICAgIGlmICghb3B0cy5mb3JjZSAmJiAob3B0cy5kaXNhYmxlUGFuIHx8IChvcHRzLnBhbk9ubHlXaGVuWm9vbWVkICYmIHNjYWxlID09PSBvcHRzLnN0YXJ0U2NhbGUpKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICB0b1ggPSBwYXJzZUZsb2F0KHRvWCBhcyBzdHJpbmcpXG4gICAgdG9ZID0gcGFyc2VGbG9hdCh0b1kgYXMgc3RyaW5nKVxuXG4gICAgaWYgKCFvcHRzLmRpc2FibGVYQXhpcykge1xuICAgICAgcmVzdWx0LnggPSAob3B0cy5yZWxhdGl2ZSA/IHggOiAwKSArIHRvWFxuICAgIH1cblxuICAgIGlmICghb3B0cy5kaXNhYmxlWUF4aXMpIHtcbiAgICAgIHJlc3VsdC55ID0gKG9wdHMucmVsYXRpdmUgPyB5IDogMCkgKyB0b1lcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcbiAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgoXG4gICAgICAgIC1kaW1zLmVsZW0ubWFyZ2luLmxlZnQgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS53aWR0aCAvIHRvU2NhbGUgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS5tYXJnaW4ubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQsXG4gICAgICAgICAgcmVzdWx0LnhcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgcmVzdWx0LnkgPSBNYXRoLm1heChcbiAgICAgICAgLWRpbXMuZWxlbS5tYXJnaW4udG9wIC0gZGltcy5wYXJlbnQucGFkZGluZy50b3AsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LmhlaWdodCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0uaGVpZ2h0IC8gdG9TY2FsZSAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIudG9wIC1cbiAgICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20sXG4gICAgICAgICAgcmVzdWx0LnlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3B0cy5jb250YWluID09PSAnb3V0c2lkZScpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCByZWFsV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgcmVhbEhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSByZWFsV2lkdGggKiB0b1NjYWxlXG4gICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSByZWFsSGVpZ2h0ICogdG9TY2FsZVxuICAgICAgY29uc3QgZGlmZkhvcml6b250YWwgPSAoc2NhbGVkV2lkdGggLSByZWFsV2lkdGgpIC8gMlxuICAgICAgY29uc3QgZGlmZlZlcnRpY2FsID0gKHNjYWxlZEhlaWdodCAtIHJlYWxIZWlnaHQpIC8gMlxuICAgICAgY29uc3QgbWluWCA9XG4gICAgICAgICgtKHNjYWxlZFdpZHRoIC0gZGltcy5wYXJlbnQud2lkdGgpIC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQgK1xuICAgICAgICAgIGRpZmZIb3Jpem9udGFsKSAvXG4gICAgICAgIHRvU2NhbGVcbiAgICAgIGNvbnN0IG1heFggPSAoZGlmZkhvcml6b250YWwgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQpIC8gdG9TY2FsZVxuICAgICAgcmVzdWx0LnggPSBNYXRoLm1heChNYXRoLm1pbihyZXN1bHQueCwgbWF4WCksIG1pblgpXG4gICAgICBjb25zdCBtaW5ZID1cbiAgICAgICAgKC0oc2NhbGVkSGVpZ2h0IC0gZGltcy5wYXJlbnQuaGVpZ2h0KSAtXG4gICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20gK1xuICAgICAgICAgIGRpZmZWZXJ0aWNhbCkgL1xuICAgICAgICB0b1NjYWxlXG4gICAgICBjb25zdCBtYXhZID0gKGRpZmZWZXJ0aWNhbCAtIGRpbXMucGFyZW50LnBhZGRpbmcudG9wKSAvIHRvU2NhbGVcbiAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LnksIG1heFkpLCBtaW5ZKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJhaW5TY2FsZSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBzY2FsZSwgb3B0cyB9XG4gICAgaWYgKCFvcHRzLmZvcmNlICYmIG9wdHMuZGlzYWJsZVpvb20pIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgcmVzdWx0LnNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgodG9TY2FsZSwgb3B0cy5taW5TY2FsZSksIG9wdHMubWF4U2NhbGUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcGFuKHRvWDogbnVtYmVyIHwgc3RyaW5nLCB0b1k6IG51bWJlciB8IHN0cmluZywgcGFuT3B0aW9ucz86IFBhbk9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5YWSh0b1gsIHRvWSwgc2NhbGUsIHBhbk9wdGlvbnMpXG4gICAgY29uc3Qgb3B0cyA9IHJlc3VsdC5vcHRzXG5cbiAgICB4ID0gcmVzdWx0LnhcbiAgICB5ID0gcmVzdWx0LnlcblxuICAgIHJldHVybiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoJ3Bhbnpvb21wYW4nLCBvcHRzKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5TY2FsZSh0b1NjYWxlLCB6b29tT3B0aW9ucylcbiAgICBjb25zdCBvcHRzID0gcmVzdWx0Lm9wdHNcbiAgICBpZiAoIW9wdHMuZm9yY2UgJiYgb3B0cy5kaXNhYmxlWm9vbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRvU2NhbGUgPSByZXN1bHQuc2NhbGVcbiAgICBsZXQgdG9YID0geFxuICAgIGxldCB0b1kgPSB5XG5cbiAgICBpZiAob3B0cy5mb2NhbCkge1xuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYWZ0ZXIgdGhlIHNjYWxlIGFuZCB0aGUgcG9pbnQgYmVmb3JlIHRoZSBzY2FsZVxuICAgICAgLy8gcGx1cyB0aGUgY3VycmVudCB0cmFuc2xhdGlvbiBhZnRlciB0aGUgc2NhbGVcbiAgICAgIC8vIG5ldXRyYWxpemVkIHRvIG5vIHNjYWxlIChhcyB0aGUgdHJhbnNmb3JtIHNjYWxlIHdpbGwgYXBwbHkgdG8gdGhlIHRyYW5zbGF0aW9uKVxuICAgICAgY29uc3QgZm9jYWwgPSBvcHRzLmZvY2FsXG4gICAgICB0b1ggPSAoZm9jYWwueCAvIHRvU2NhbGUgLSBmb2NhbC54IC8gc2NhbGUgKyB4ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgICB0b1kgPSAoZm9jYWwueSAvIHRvU2NhbGUgLSBmb2NhbC55IC8gc2NhbGUgKyB5ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgfVxuICAgIGNvbnN0IHBhblJlc3VsdCA9IGNvbnN0cmFpblhZKHRvWCwgdG9ZLCB0b1NjYWxlLCB7IHJlbGF0aXZlOiBmYWxzZSwgZm9yY2U6IHRydWUgfSlcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICBzY2FsZSA9IHRvU2NhbGVcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tem9vbScsIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW5PdXQoaXNJbjogYm9vbGVhbiwgem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMsIGFuaW1hdGU6IHRydWUsIC4uLnpvb21PcHRpb25zIH1cbiAgICByZXR1cm4gem9vbShzY2FsZSAqIE1hdGguZXhwKChpc0luID8gMSA6IC0xKSAqIG9wdHMuc3RlcCksIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW4oem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIHJldHVybiB6b29tSW5PdXQodHJ1ZSwgem9vbU9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tT3V0KHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICByZXR1cm4gem9vbUluT3V0KGZhbHNlLCB6b29tT3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21Ub1BvaW50KFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwb2ludDogeyBjbGllbnRYOiBudW1iZXI7IGNsaWVudFk6IG51bWJlciB9LFxuICAgIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcblxuICAgIC8vIEluc3RlYWQgb2YgdGhpbmtpbmcgb2Ygb3BlcmF0aW5nIG9uIHRoZSBwYW56b29tIGVsZW1lbnQsXG4gICAgLy8gdGhpbmsgb2Ygb3BlcmF0aW5nIG9uIHRoZSBhcmVhIGluc2lkZSB0aGUgcGFuem9vbVxuICAgIC8vIGVsZW1lbnQncyBwYXJlbnRcbiAgICAvLyBTdWJ0cmFjdCBwYWRkaW5nIGFuZCBib3JkZXJcbiAgICBjb25zdCBlZmZlY3RpdmVBcmVhID0ge1xuICAgICAgd2lkdGg6XG4gICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5yaWdodCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0LFxuICAgICAgaGVpZ2h0OlxuICAgICAgICBkaW1zLnBhcmVudC5oZWlnaHQgLVxuICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcuYm90dG9tIC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b21cbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdGhlIGNsaWVudFgvY2xpZW50WSB0byBpZ25vcmUgdGhlIGFyZWFcbiAgICAvLyBvdXRzaWRlIHRoZSBlZmZlY3RpdmUgYXJlYVxuICAgIGxldCBjbGllbnRYID1cbiAgICAgIHBvaW50LmNsaWVudFggLVxuICAgICAgZGltcy5wYXJlbnQubGVmdCAtXG4gICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLVxuICAgICAgZGltcy5lbGVtLm1hcmdpbi5sZWZ0XG4gICAgbGV0IGNsaWVudFkgPVxuICAgICAgcG9pbnQuY2xpZW50WSAtXG4gICAgICBkaW1zLnBhcmVudC50b3AgLVxuICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcFxuXG4gICAgLy8gQWRqdXN0IHRoZSBjbGllbnRYL2NsaWVudFkgZm9yIEhUTUwgZWxlbWVudHMsXG4gICAgLy8gYmVjYXVzZSB0aGV5IGhhdmUgYSB0cmFuc2Zvcm0tb3JpZ2luIG9mIDUwJSA1MCVcbiAgICBpZiAoIWlzU1ZHKSB7XG4gICAgICBjbGllbnRYIC09IGRpbXMuZWxlbS53aWR0aCAvIHNjYWxlIC8gMlxuICAgICAgY2xpZW50WSAtPSBkaW1zLmVsZW0uaGVpZ2h0IC8gc2NhbGUgLyAyXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgbW91c2UgcG9pbnQgZnJvbSBpdCdzIHBvc2l0aW9uIG92ZXIgdGhlXG4gICAgLy8gZWZmZWN0aXZlIGFyZWEgYmVmb3JlIHRoZSBzY2FsZSB0byB0aGUgcG9zaXRpb25cbiAgICAvLyBvdmVyIHRoZSBlZmZlY3RpdmUgYXJlYSBhZnRlciB0aGUgc2NhbGUuXG4gICAgY29uc3QgZm9jYWwgPSB7XG4gICAgICB4OiAoY2xpZW50WCAvIGVmZmVjdGl2ZUFyZWEud2lkdGgpICogKGVmZmVjdGl2ZUFyZWEud2lkdGggKiB0b1NjYWxlKSxcbiAgICAgIHk6IChjbGllbnRZIC8gZWZmZWN0aXZlQXJlYS5oZWlnaHQpICogKGVmZmVjdGl2ZUFyZWEuaGVpZ2h0ICogdG9TY2FsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gem9vbSh0b1NjYWxlLCB7IC4uLnpvb21PcHRpb25zLCBmb2NhbCwgYW5pbWF0ZTogZmFsc2UgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21XaXRoV2hlZWwoZXZlbnQ6IFdoZWVsRXZlbnQsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICAvLyBOZWVkIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgaGVyZVxuICAgIC8vIG9yIGl0IGNvbmZsaWN0cyB3aXRoIHJlZ3VsYXIgcGFnZSBzY3JvbGxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG5cbiAgICAvLyBOb3JtYWxpemUgdG8gZGVsdGFYIGluIGNhc2Ugc2hpZnQgbW9kaWZpZXIgaXMgdXNlZCBvbiBNYWNcbiAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhWSA9PT0gMCAmJiBldmVudC5kZWx0YVggPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVlcbiAgICBjb25zdCB3aGVlbCA9IGRlbHRhIDwgMCA/IDEgOiAtMVxuICAgIGNvbnN0IHRvU2NhbGUgPSBjb25zdHJhaW5TY2FsZShzY2FsZSAqIE1hdGguZXhwKCh3aGVlbCAqIG9wdHMuc3RlcCkgLyAzKSwgb3B0cykuc2NhbGVcblxuICAgIHJldHVybiB6b29tVG9Qb2ludCh0b1NjYWxlLCBldmVudCwgb3B0cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KHJlc2V0T3B0aW9ucz86IFBhbnpvb21PcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgYW5pbWF0ZTogdHJ1ZSwgLi4ucmVzZXRPcHRpb25zIH1cbiAgICBzY2FsZSA9IGNvbnN0cmFpblNjYWxlKG9wdHMuc3RhcnRTY2FsZSwgb3B0cykuc2NhbGVcbiAgICBjb25zdCBwYW5SZXN1bHQgPSBjb25zdHJhaW5YWShvcHRzLnN0YXJ0WCwgb3B0cy5zdGFydFksIHNjYWxlLCBvcHRzKVxuICAgIHggPSBwYW5SZXN1bHQueFxuICAgIHkgPSBwYW5SZXN1bHQueVxuICAgIHJldHVybiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoJ3Bhbnpvb21yZXNldCcsIG9wdHMpXG4gIH1cblxuICBsZXQgb3JpZ1g6IG51bWJlclxuICBsZXQgb3JpZ1k6IG51bWJlclxuICBsZXQgc3RhcnRDbGllbnRYOiBudW1iZXJcbiAgbGV0IHN0YXJ0Q2xpZW50WTogbnVtYmVyXG4gIGxldCBzdGFydFNjYWxlOiBudW1iZXJcbiAgbGV0IHN0YXJ0RGlzdGFuY2U6IG51bWJlclxuICBjb25zdCBwb2ludGVyczogUG9pbnRlckV2ZW50W10gPSBbXVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURvd24oZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIC8vIERvbid0IGhhbmRsZSB0aGlzIGV2ZW50IGlmIHRoZSB0YXJnZXQgaXMgZXhjbHVkZWRcbiAgICBpZiAoaXNFeGNsdWRlZChldmVudC50YXJnZXQgYXMgRWxlbWVudCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhZGRQb2ludGVyKHBvaW50ZXJzLCBldmVudClcbiAgICBpc1Bhbm5pbmcgPSB0cnVlXG4gICAgb3B0aW9ucy5oYW5kbGVTdGFydEV2ZW50KGV2ZW50KVxuICAgIG9yaWdYID0geFxuICAgIG9yaWdZID0geVxuXG4gICAgdHJpZ2dlcigncGFuem9vbXN0YXJ0JywgeyB4LCB5LCBzY2FsZSB9LCBvcHRpb25zKVxuXG4gICAgLy8gVGhpcyB3b3JrcyB3aGV0aGVyIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgIC8vIHBvaW50ZXJzIG9yIG5vdFxuICAgIGNvbnN0IHBvaW50ID0gZ2V0TWlkZGxlKHBvaW50ZXJzKVxuICAgIHN0YXJ0Q2xpZW50WCA9IHBvaW50LmNsaWVudFhcbiAgICBzdGFydENsaWVudFkgPSBwb2ludC5jbGllbnRZXG4gICAgc3RhcnRTY2FsZSA9IHNjYWxlXG4gICAgc3RhcnREaXN0YW5jZSA9IGdldERpc3RhbmNlKHBvaW50ZXJzKVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZShldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgaWYgKFxuICAgICAgIWlzUGFubmluZyB8fFxuICAgICAgb3JpZ1ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgb3JpZ1kgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgc3RhcnRDbGllbnRYID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHN0YXJ0Q2xpZW50WSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYWRkUG9pbnRlcihwb2ludGVycywgZXZlbnQpXG4gICAgY29uc3QgY3VycmVudCA9IGdldE1pZGRsZShwb2ludGVycylcbiAgICBpZiAocG9pbnRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gVXNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCAyIHBvaW50ZXJzXG4gICAgICAvLyB0byBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgc2NhbGVcbiAgICAgIGNvbnN0IGRpZmYgPSBnZXREaXN0YW5jZShwb2ludGVycykgLSBzdGFydERpc3RhbmNlXG4gICAgICBjb25zdCB0b1NjYWxlID0gY29uc3RyYWluU2NhbGUoKGRpZmYgKiBvcHRpb25zLnN0ZXApIC8gODAgKyBzdGFydFNjYWxlKS5zY2FsZVxuICAgICAgem9vbVRvUG9pbnQodG9TY2FsZSwgY3VycmVudClcbiAgICB9XG5cbiAgICBwYW4oXG4gICAgICBvcmlnWCArIChjdXJyZW50LmNsaWVudFggLSBzdGFydENsaWVudFgpIC8gc2NhbGUsXG4gICAgICBvcmlnWSArIChjdXJyZW50LmNsaWVudFkgLSBzdGFydENsaWVudFkpIC8gc2NhbGUsXG4gICAgICB7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVXAoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIC8vIERvbid0IGNhbGwgcGFuem9vbWVuZCB3aGVuIHBhbm5pbmcgd2l0aCAyIHRvdWNoZXNcbiAgICAvLyB1bnRpbCBib3RoIHRvdWNoZXMgZW5kXG4gICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdHJpZ2dlcigncGFuem9vbWVuZCcsIHsgeCwgeSwgc2NhbGUgfSwgb3B0aW9ucylcbiAgICB9XG4gICAgLy8gTm90ZTogZG9uJ3QgcmVtb3ZlIGFsbCBwb2ludGVyc1xuICAgIC8vIENhbiByZXN0YXJ0IHdpdGhvdXQgaGF2aW5nIHRvIHJlaW5pdGlhdGUgYWxsIG9mIHRoZW1cbiAgICAvLyBSZW1vdmUgdGhlIHBvaW50ZXIgcmVnYXJkbGVzcyBvZiB0aGUgaXNQYW5uaW5nIHN0YXRlXG4gICAgcmVtb3ZlUG9pbnRlcihwb2ludGVycywgZXZlbnQpXG4gICAgaWYgKCFpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpc1Bhbm5pbmcgPSBmYWxzZVxuICAgIG9yaWdYID0gb3JpZ1kgPSBzdGFydENsaWVudFggPSBzdGFydENsaWVudFkgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5kaXNhYmxlUGFuKSB7XG4gICAgb25Qb2ludGVyKCdkb3duJywgZWxlbSwgaGFuZGxlRG93bilcbiAgICBvblBvaW50ZXIoJ21vdmUnLCBkb2N1bWVudCwgbW92ZSwgeyBwYXNzaXZlOiB0cnVlIH0pXG4gICAgb25Qb2ludGVyKCd1cCcsIGRvY3VtZW50LCBoYW5kbGVVcCwgeyBwYXNzaXZlOiB0cnVlIH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGRlc3Ryb3lQb2ludGVyKCdkb3duJywgZWxlbSwgaGFuZGxlRG93bilcbiAgICBkZXN0cm95UG9pbnRlcignbW92ZScsIGRvY3VtZW50LCBtb3ZlKVxuICAgIGRlc3Ryb3lQb2ludGVyKCd1cCcsIGRvY3VtZW50LCBoYW5kbGVVcClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGVzdHJveSxcbiAgICBnZXRQYW46ICgpID0+ICh7IHgsIHkgfSksXG4gICAgZ2V0U2NhbGU6ICgpID0+IHNjYWxlLFxuICAgIGdldE9wdGlvbnM6ICgpID0+IHNoYWxsb3dDbG9uZShvcHRpb25zKSxcbiAgICBwYW4sXG4gICAgcmVzZXQsXG4gICAgc2V0T3B0aW9ucyxcbiAgICBzZXRTdHlsZTogKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc2V0U3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpLFxuICAgIHpvb20sXG4gICAgem9vbUluLFxuICAgIHpvb21PdXQsXG4gICAgem9vbVRvUG9pbnQsXG4gICAgem9vbVdpdGhXaGVlbFxuICB9XG59XG5cblBhbnpvb20uZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCBQYW56b29tXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n"
    )
  },
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_panzoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\nconsole.log('This is a demo version of Panzoom for testing.');\nconsole.log('It exposes a global (window.Panzoom) and should not be used in production.');\nwindow.Panzoom = _src_panzoom__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vL2dsb2JhbC1wYW56b29tLnRzPzdiODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFvQztBQUVwQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdEQUFnRCxDQUFDO0FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsNEVBQTRFLENBQUM7QUFPekYsTUFBTSxDQUFDLE9BQU8sR0FBRyw0REFBTyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhbnpvb20gZnJvbSAnLi4vc3JjL3Bhbnpvb20nXG5cbmNvbnNvbGUubG9nKCdUaGlzIGlzIGEgZGVtbyB2ZXJzaW9uIG9mIFBhbnpvb20gZm9yIHRlc3RpbmcuJylcbmNvbnNvbGUubG9nKCdJdCBleHBvc2VzIGEgZ2xvYmFsICh3aW5kb3cuUGFuem9vbSkgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLicpXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGFuem9vbTogdHlwZW9mIFBhbnpvb21cbiAgfVxufVxud2luZG93LlBhbnpvb20gPSBQYW56b29tXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n"
    )
  },
  function(module, exports) {
    eval(
      "/* eslint-disable no-var */\n// Support: IE11 only\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n// Support: IE11 only\n// CustomEvent is an object instead of a constructor\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzLmpzPzA2NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gU3VwcG9ydDogSUUxMSBvbmx5XG5pZiAod2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG59XG4vLyBTdXBwb3J0OiBJRTExIG9ubHlcbi8vIEN1c3RvbUV2ZW50IGlzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3JcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogbnVsbCB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKVxuICAgIHJldHVybiBldnRcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n"
    )
  }
])
