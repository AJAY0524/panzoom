!(function(Q) {
  var U = window.webpackHotUpdate
  window.webpackHotUpdate = function(Q, F) {
    !(function(Q, U) {
      if (!u[Q] || !C[Q]) return
      for (var F in ((C[Q] = !1), U)) Object.prototype.hasOwnProperty.call(U, F) && (b[F] = U[F])
      0 == --L && 0 === a && E()
    })(Q, F),
      U && U(Q, F)
  }
  var F,
    B = !0,
    n = '3edc449c0ab9b552d0df',
    e = 1e4,
    s = {},
    t = [],
    l = []
  function c(Q) {
    var U = R[Q]
    if (!U) return V
    var B = function(B) {
        return (
          U.hot.active
            ? (R[B] ? -1 === R[B].parents.indexOf(Q) && R[B].parents.push(Q) : ((t = [Q]), (F = B)),
              -1 === U.children.indexOf(B) && U.children.push(B))
            : (console.warn('[HMR] unexpected require(' + B + ') from disposed module ' + Q),
              (t = [])),
          V(B)
        )
      },
      n = function(Q) {
        return {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return V[Q]
          },
          set: function(U) {
            V[Q] = U
          }
        }
      }
    for (var e in V)
      Object.prototype.hasOwnProperty.call(V, e) &&
        'e' !== e &&
        't' !== e &&
        Object.defineProperty(B, e, n(e))
    return (
      (B.e = function(Q) {
        return (
          'ready' === d && x('prepare'),
          a++,
          V.e(Q).then(U, function(Q) {
            throw (U(), Q)
          })
        )
        function U() {
          a--, 'prepare' === d && (G[Q] || r(Q), 0 === a && 0 === L && E())
        }
      }),
      (B.t = function(Q, U) {
        return 1 & U && (Q = B(Q)), V.t(Q, -2 & U)
      }),
      B
    )
  }
  function i(Q) {
    var U = {
      _acceptedDependencies: {},
      _declinedDependencies: {},
      _selfAccepted: !1,
      _selfDeclined: !1,
      _disposeHandlers: [],
      _main: F !== Q,
      active: !0,
      accept: function(Q, F) {
        if (void 0 === Q) U._selfAccepted = !0
        else if ('function' == typeof Q) U._selfAccepted = Q
        else if ('object' == typeof Q)
          for (var B = 0; B < Q.length; B++) U._acceptedDependencies[Q[B]] = F || function() {}
        else U._acceptedDependencies[Q] = F || function() {}
      },
      decline: function(Q) {
        if (void 0 === Q) U._selfDeclined = !0
        else if ('object' == typeof Q)
          for (var F = 0; F < Q.length; F++) U._declinedDependencies[Q[F]] = !0
        else U._declinedDependencies[Q] = !0
      },
      dispose: function(Q) {
        U._disposeHandlers.push(Q)
      },
      addDisposeHandler: function(Q) {
        U._disposeHandlers.push(Q)
      },
      removeDisposeHandler: function(Q) {
        var F = U._disposeHandlers.indexOf(Q)
        F >= 0 && U._disposeHandlers.splice(F, 1)
      },
      check: S,
      apply: Z,
      status: function(Q) {
        if (!Q) return d
        g.push(Q)
      },
      addStatusHandler: function(Q) {
        g.push(Q)
      },
      removeStatusHandler: function(Q) {
        var U = g.indexOf(Q)
        U >= 0 && g.splice(U, 1)
      },
      data: s[Q]
    }
    return (F = void 0), U
  }
  var g = [],
    d = 'idle'
  function x(Q) {
    d = Q
    for (var U = 0; U < g.length; U++) g[U].call(null, Q)
  }
  var I,
    b,
    o,
    L = 0,
    a = 0,
    G = {},
    C = {},
    u = {}
  function y(Q) {
    return +Q + '' === Q ? +Q : Q
  }
  function S(Q) {
    if ('idle' !== d) throw new Error('check() is only allowed in idle status')
    return (
      (B = Q),
      x('check'),
      ((U = e),
      (U = U || 1e4),
      new Promise(function(Q, F) {
        if ('undefined' == typeof XMLHttpRequest) return F(new Error('No browser support'))
        try {
          var B = new XMLHttpRequest(),
            e = V.p + '' + n + '.hot-update.json'
          B.open('GET', e, !0), (B.timeout = U), B.send(null)
        } catch (Q) {
          return F(Q)
        }
        B.onreadystatechange = function() {
          if (4 === B.readyState)
            if (0 === B.status) F(new Error('Manifest request to ' + e + ' timed out.'))
            else if (404 === B.status) Q()
            else if (200 !== B.status && 304 !== B.status)
              F(new Error('Manifest request to ' + e + ' failed.'))
            else {
              try {
                var U = JSON.parse(B.responseText)
              } catch (Q) {
                return void F(Q)
              }
              Q(U)
            }
        }
      })).then(function(Q) {
        if (!Q) return x('idle'), null
        ;(C = {}), (G = {}), (u = Q.c), (o = Q.h), x('prepare')
        var U = new Promise(function(Q, U) {
          I = { resolve: Q, reject: U }
        })
        b = {}
        return r(1), 'prepare' === d && 0 === a && 0 === L && E(), U
      })
    )
    var U
  }
  function r(Q) {
    u[Q]
      ? ((C[Q] = !0),
        L++,
        (function(Q) {
          var U = document.createElement('script')
          ;(U.charset = 'utf-8'),
            (U.src = V.p + '' + Q + '.' + n + '.hot-update.js'),
            document.head.appendChild(U)
        })(Q))
      : (G[Q] = !0)
  }
  function E() {
    x('ready')
    var Q = I
    if (((I = null), Q))
      if (B)
        Promise.resolve()
          .then(function() {
            return Z(B)
          })
          .then(
            function(U) {
              Q.resolve(U)
            },
            function(U) {
              Q.reject(U)
            }
          )
      else {
        var U = []
        for (var F in b) Object.prototype.hasOwnProperty.call(b, F) && U.push(y(F))
        Q.resolve(U)
      }
  }
  function Z(U) {
    if ('ready' !== d) throw new Error('apply() is only allowed in ready status')
    var F, B, e, l, c
    function i(Q) {
      for (
        var U = [Q],
          F = {},
          B = U.map(function(Q) {
            return { chain: [Q], id: Q }
          });
        B.length > 0;

      ) {
        var n = B.pop(),
          e = n.id,
          s = n.chain
        if ((l = R[e]) && !l.hot._selfAccepted) {
          if (l.hot._selfDeclined) return { type: 'self-declined', chain: s, moduleId: e }
          if (l.hot._main) return { type: 'unaccepted', chain: s, moduleId: e }
          for (var t = 0; t < l.parents.length; t++) {
            var c = l.parents[t],
              i = R[c]
            if (i) {
              if (i.hot._declinedDependencies[e])
                return { type: 'declined', chain: s.concat([c]), moduleId: e, parentId: c }
              ;-1 === U.indexOf(c) &&
                (i.hot._acceptedDependencies[e]
                  ? (F[c] || (F[c] = []), g(F[c], [e]))
                  : (delete F[c], U.push(c), B.push({ chain: s.concat([c]), id: c })))
            }
          }
        }
      }
      return { type: 'accepted', moduleId: Q, outdatedModules: U, outdatedDependencies: F }
    }
    function g(Q, U) {
      for (var F = 0; F < U.length; F++) {
        var B = U[F]
        ;-1 === Q.indexOf(B) && Q.push(B)
      }
    }
    U = U || {}
    var I = {},
      L = [],
      a = {},
      G = function() {
        console.warn('[HMR] unexpected require(' + S.moduleId + ') to disposed module')
      }
    for (var C in b)
      if (Object.prototype.hasOwnProperty.call(b, C)) {
        var S
        c = y(C)
        var r = !1,
          E = !1,
          Z = !1,
          N = ''
        switch (
          ((S = b[C] ? i(c) : { type: 'disposed', moduleId: C }).chain &&
            (N = '\nUpdate propagation: ' + S.chain.join(' -> ')),
          S.type)
        ) {
          case 'self-declined':
            U.onDeclined && U.onDeclined(S),
              U.ignoreDeclined ||
                (r = new Error('Aborted because of self decline: ' + S.moduleId + N))
            break
          case 'declined':
            U.onDeclined && U.onDeclined(S),
              U.ignoreDeclined ||
                (r = new Error(
                  'Aborted because of declined dependency: ' + S.moduleId + ' in ' + S.parentId + N
                ))
            break
          case 'unaccepted':
            U.onUnaccepted && U.onUnaccepted(S),
              U.ignoreUnaccepted || (r = new Error('Aborted because ' + c + ' is not accepted' + N))
            break
          case 'accepted':
            U.onAccepted && U.onAccepted(S), (E = !0)
            break
          case 'disposed':
            U.onDisposed && U.onDisposed(S), (Z = !0)
            break
          default:
            throw new Error('Unexception type ' + S.type)
        }
        if (r) return x('abort'), Promise.reject(r)
        if (E)
          for (c in ((a[c] = b[c]), g(L, S.outdatedModules), S.outdatedDependencies))
            Object.prototype.hasOwnProperty.call(S.outdatedDependencies, c) &&
              (I[c] || (I[c] = []), g(I[c], S.outdatedDependencies[c]))
        Z && (g(L, [S.moduleId]), (a[c] = G))
      }
    var p,
      m = []
    for (B = 0; B < L.length; B++)
      (c = L[B]),
        R[c] &&
          R[c].hot._selfAccepted &&
          a[c] !== G &&
          m.push({ module: c, errorHandler: R[c].hot._selfAccepted })
    x('dispose'),
      Object.keys(u).forEach(function(Q) {
        !1 === u[Q] &&
          (function(Q) {
            delete installedChunks[Q]
          })(Q)
      })
    for (var W, D, A = L.slice(); A.length > 0; )
      if (((c = A.pop()), (l = R[c]))) {
        var h = {},
          H = l.hot._disposeHandlers
        for (e = 0; e < H.length; e++) (F = H[e])(h)
        for (
          s[c] = h, l.hot.active = !1, delete R[c], delete I[c], e = 0;
          e < l.children.length;
          e++
        ) {
          var X = R[l.children[e]]
          X && (p = X.parents.indexOf(c)) >= 0 && X.parents.splice(p, 1)
        }
      }
    for (c in I)
      if (Object.prototype.hasOwnProperty.call(I, c) && (l = R[c]))
        for (D = I[c], e = 0; e < D.length; e++)
          (W = D[e]), (p = l.children.indexOf(W)) >= 0 && l.children.splice(p, 1)
    for (c in (x('apply'), (n = o), a)) Object.prototype.hasOwnProperty.call(a, c) && (Q[c] = a[c])
    var v = null
    for (c in I)
      if (Object.prototype.hasOwnProperty.call(I, c) && (l = R[c])) {
        D = I[c]
        var J = []
        for (B = 0; B < D.length; B++)
          if (((W = D[B]), (F = l.hot._acceptedDependencies[W]))) {
            if (-1 !== J.indexOf(F)) continue
            J.push(F)
          }
        for (B = 0; B < J.length; B++) {
          F = J[B]
          try {
            F(D)
          } catch (Q) {
            U.onErrored &&
              U.onErrored({ type: 'accept-errored', moduleId: c, dependencyId: D[B], error: Q }),
              U.ignoreErrored || v || (v = Q)
          }
        }
      }
    for (B = 0; B < m.length; B++) {
      var M = m[B]
      ;(c = M.module), (t = [c])
      try {
        V(c)
      } catch (Q) {
        if ('function' == typeof M.errorHandler)
          try {
            M.errorHandler(Q)
          } catch (F) {
            U.onErrored &&
              U.onErrored({
                type: 'self-accept-error-handler-errored',
                moduleId: c,
                error: F,
                originalError: Q
              }),
              U.ignoreErrored || v || (v = F),
              v || (v = Q)
          }
        else
          U.onErrored && U.onErrored({ type: 'self-accept-errored', moduleId: c, error: Q }),
            U.ignoreErrored || v || (v = Q)
      }
    }
    return v
      ? (x('fail'), Promise.reject(v))
      : (x('idle'),
        new Promise(function(Q) {
          Q(L)
        }))
  }
  var R = {}
  function V(U) {
    if (R[U]) return R[U].exports
    var F = (R[U] = {
      i: U,
      l: !1,
      exports: {},
      hot: i(U),
      parents: ((l = t), (t = []), l),
      children: []
    })
    return Q[U].call(F.exports, F, F.exports, c(U)), (F.l = !0), F.exports
  }
  ;(V.m = Q),
    (V.c = R),
    (V.d = function(Q, U, F) {
      V.o(Q, U) || Object.defineProperty(Q, U, { enumerable: !0, get: F })
    }),
    (V.r = function(Q) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(Q, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(Q, '__esModule', { value: !0 })
    }),
    (V.t = function(Q, U) {
      if ((1 & U && (Q = V(Q)), 8 & U)) return Q
      if (4 & U && 'object' == typeof Q && Q && Q.__esModule) return Q
      var F = Object.create(null)
      if (
        (V.r(F),
        Object.defineProperty(F, 'default', { enumerable: !0, value: Q }),
        2 & U && 'string' != typeof Q)
      )
        for (var B in Q)
          V.d(
            F,
            B,
            function(U) {
              return Q[U]
            }.bind(null, B)
          )
      return F
    }),
    (V.n = function(Q) {
      var U =
        Q && Q.__esModule
          ? function() {
              return Q.default
            }
          : function() {
              return Q
            }
      return V.d(U, 'a', U), U
    }),
    (V.o = function(Q, U) {
      return Object.prototype.hasOwnProperty.call(Q, U)
    }),
    (V.p = ''),
    (V.h = function() {
      return n
    }),
    c(3)((V.s = 3))
})([
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "\n// EXTERNAL MODULE: ./src/polyfills.js\nvar polyfills = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./src/pointers.ts\n/**\n * Utilites for working with multiple pointer events\n */\nfunction findEventIndex(pointers, event) {\n    var i = pointers.length;\n    while (i--) {\n        if (pointers[i].pointerId === event.pointerId) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction addPointer(pointers, event) {\n    var i;\n    // Add touches if applicable\n    if (event.touches) {\n        i = 0;\n        for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {\n            var touch = _a[_i];\n            touch.pointerId = i++;\n            addPointer(pointers, touch);\n        }\n        return;\n    }\n    i = findEventIndex(pointers, event);\n    // Update if already present\n    if (i > -1) {\n        pointers.splice(i, 1);\n    }\n    pointers.push(event);\n}\nfunction removePointer(pointers, event) {\n    // Add touches if applicable\n    if (event.touches) {\n        // Remove all touches\n        while (pointers.length) {\n            pointers.pop();\n        }\n        return;\n    }\n    var i = findEventIndex(pointers, event);\n    if (i > -1) {\n        pointers.splice(i, 1);\n    }\n}\n/**\n * Calculates a center point between\n * the given pointer events, for panning\n * with multiple pointers.\n */\nfunction getMiddle(pointers) {\n    // Copy to avoid changing by reference\n    pointers = pointers.slice(0);\n    var event1 = pointers.pop();\n    var event2;\n    while ((event2 = pointers.pop())) {\n        event1 = {\n            clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,\n            clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY\n        };\n    }\n    return event1;\n}\n/**\n * Calculates the distance between two points\n * for pinch zooming.\n * Limits to the first 2\n */\nfunction getDistance(pointers) {\n    if (pointers.length < 2) {\n        return 0;\n    }\n    var event1 = pointers[0];\n    var event2 = pointers[1];\n    return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) +\n        Math.pow(Math.abs(event2.clientY - event1.clientY), 2));\n}\n\n// CONCATENATED MODULE: ./src/events.ts\nvar events;\nif (typeof window.PointerEvent === 'function') {\n    events = {\n        down: 'pointerdown',\n        move: 'pointermove',\n        up: 'pointerup pointerleave pointercancel'\n    };\n}\nelse if (typeof window.TouchEvent === 'function') {\n    events = {\n        down: 'touchstart',\n        move: 'touchmove',\n        up: 'touchend touchcancel'\n    };\n}\nelse {\n    events = {\n        down: 'mousedown',\n        move: 'mousemove',\n        up: 'mouseup mouseleave'\n    };\n}\nfunction onPointer(event, elem, handler, eventOpts) {\n    events[event].split(' ').forEach(function (name) {\n        ;\n        elem.addEventListener(name, handler, eventOpts);\n    });\n}\nfunction destroyPointer(event, elem, handler) {\n    events[event].split(' ').forEach(function (name) {\n        ;\n        elem.removeEventListener(name, handler);\n    });\n}\n\n// CONCATENATED MODULE: ./src/css.ts\n/**\n * Proper prefixing for cross-browser compatibility\n */\nvar divStyle = document.createElement('div').style;\nvar prefixes = ['webkit', 'moz', 'ms'];\nvar prefixCache = {};\nfunction getPrefixedName(name) {\n    if (prefixCache[name]) {\n        return prefixCache[name];\n    }\n    if (name in divStyle) {\n        return (prefixCache[name] = name);\n    }\n    var capName = name[0].toUpperCase() + name.slice(1);\n    var i = prefixes.length;\n    while (i--) {\n        var prefixedName = \"\" + prefixes[i] + capName;\n        if (prefixedName in divStyle) {\n            return (prefixCache[name] = prefixedName);\n        }\n    }\n}\n/**\n * Gets a style value expected to be a number\n */\nfunction getCSSNum(name, style) {\n    return parseFloat(style[getPrefixedName(name)]) || 0;\n}\nfunction getBoxStyle(elem, name, style) {\n    if (style === void 0) { style = window.getComputedStyle(elem); }\n    // Support: FF 68+\n    // Firefox requires specificity for border\n    var suffix = name === 'border' ? 'Width' : '';\n    return {\n        left: getCSSNum(name + \"Left\" + suffix, style),\n        right: getCSSNum(name + \"Right\" + suffix, style),\n        top: getCSSNum(name + \"Top\" + suffix, style),\n        bottom: getCSSNum(name + \"Bottom\" + suffix, style)\n    };\n}\n/**\n * Set a style using the properly prefixed name\n */\nfunction setStyle(elem, name, value) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    elem.style[getPrefixedName(name)] = value;\n}\n/**\n * Constructs the transition from panzoom options\n * and takes care of prefixing the transition and transform\n */\nfunction setTransition(elem, options) {\n    var transition = getPrefixedName('transition');\n    var transform = getPrefixedName('transform');\n    setStyle(elem, transition, transform + \" \" + options.duration + \"ms \" + options.easing);\n}\n/**\n * Set the transform using the proper prefix\n */\nfunction setTransform(elem, _a, options) {\n    var x = _a.x, y = _a.y, scale = _a.scale;\n    if (options === void 0) { options = {}; }\n    if (typeof options.animate === 'boolean') {\n        if (options.animate) {\n            setTransition(elem, options);\n        }\n        else {\n            setStyle(elem, 'transition', 'none');\n        }\n    }\n    requestAnimationFrame(function () {\n        setStyle(elem, 'transform', \"scale(\" + scale + \") translate(\" + x + \"px, \" + y + \"px)\");\n    });\n}\n/**\n * Dimensions used in containment and focal point zooming\n */\nfunction getDimensions(elem) {\n    var parent = elem.parentElement;\n    var style = window.getComputedStyle(elem);\n    var parentStyle = window.getComputedStyle(parent);\n    var rectElem = elem.getBoundingClientRect();\n    var rectParent = parent.getBoundingClientRect();\n    return {\n        elem: {\n            style: style,\n            width: rectElem.width,\n            height: rectElem.height,\n            top: rectElem.top,\n            bottom: rectElem.bottom,\n            left: rectElem.left,\n            right: rectElem.right,\n            margin: getBoxStyle(elem, 'margin', style),\n            border: getBoxStyle(elem, 'border', style)\n        },\n        parent: {\n            style: parentStyle,\n            width: rectParent.width,\n            height: rectParent.height,\n            top: rectParent.top,\n            bottom: rectParent.bottom,\n            left: rectParent.left,\n            right: rectParent.right,\n            padding: getBoxStyle(parent, 'padding', parentStyle),\n            border: getBoxStyle(parent, 'border', parentStyle)\n        }\n    };\n}\n\n// CONCATENATED MODULE: ./src/isAttached.ts\n/**\n * Determine if an element is attached to the DOM\n * Panzoom requires this so events work properly\n */\nfunction isAttached(elem) {\n    var doc = elem.ownerDocument;\n    var parent = elem.parentElement;\n    return doc && parent && doc.nodeType === 9 && parent.nodeType === 1 && doc.contains(parent);\n}\n\n// CONCATENATED MODULE: ./src/isSVGElement.ts\n/**\n * Determine if an element is SVG by checking the namespace\n * Exception: the <svg> element itself should be treated like HTML\n */\nvar rsvg = /^http:[\\w\\.\\/]+svg$/;\nfunction isSVGElement(elem) {\n    return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';\n}\n\n// CONCATENATED MODULE: ./src/shallowClone.ts\nfunction shallowClone(obj) {\n    var clone = {};\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            clone[key] = obj[key];\n        }\n    }\n    return clone;\n}\n\n// CONCATENATED MODULE: ./src/panzoom.ts\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/**\n * Panzoom for panning and zooming elements using CSS transforms\n * https://github.com/timmywil/panzoom\n *\n * Copyright Timmy Willison and other contributors\n * Released under the MIT license\n * https://github.com/timmywil/panzoom/blob/master/MIT-License.txt\n *\n */\n\n\n\n\n\n\n\nvar defaultOptions = {\n    animate: false,\n    cursor: 'move',\n    disablePan: false,\n    disableZoom: false,\n    disableXAxis: false,\n    disableYAxis: false,\n    duration: 200,\n    easing: 'ease-in-out',\n    exclude: [],\n    excludeClass: 'panzoom-exclude',\n    handleStartEvent: function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n    },\n    maxScale: 4,\n    minScale: 0.125,\n    overflow: 'hidden',\n    panOnlyWhenZoomed: false,\n    relative: false,\n    setTransform: setTransform,\n    startX: 0,\n    startY: 0,\n    startScale: 1,\n    step: 0.3\n};\nfunction Panzoom(elem, options) {\n    if (!elem) {\n        throw new Error('Panzoom requires an element as an argument');\n    }\n    if (elem.nodeType !== 1) {\n        throw new Error('Panzoom requires an element with a nodeType of 1');\n    }\n    if (!isAttached(elem)) {\n        throw new Error('Panzoom should be called on elements that have been attached to the DOM');\n    }\n    options = __assign(__assign({}, defaultOptions), options);\n    var isSVG = isSVGElement(elem);\n    // Set overflow on the parent\n    var parent = elem.parentElement;\n    parent.style.overflow = options.overflow;\n    parent.style.userSelect = 'none';\n    // This is important for mobile to\n    // prevent scrolling while panning\n    parent.style.touchAction = 'none';\n    // Set some default styles on the panzoom element\n    elem.style.cursor = options.cursor;\n    elem.style.userSelect = 'none';\n    elem.style.touchAction = 'none';\n    // The default for HTML is '50% 50%'\n    // The default for SVG is '0 0'\n    // SVG can't be changed in IE\n    setStyle(elem, 'transformOrigin', typeof options.origin === 'string' ? options.origin : isSVG ? '0 0' : '50% 50%');\n    function setOptions(opts) {\n        if (opts === void 0) { opts = {}; }\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                options[key] = opts[key];\n            }\n        }\n        // Handle option side-effects\n        if (opts.hasOwnProperty('cursor')) {\n            elem.style.cursor = opts.cursor;\n        }\n        if (opts.hasOwnProperty('overflow')) {\n            parent.style.overflow = opts.overflow;\n        }\n        if (opts.hasOwnProperty('minScale') ||\n            opts.hasOwnProperty('maxScale') ||\n            opts.hasOwnProperty('contain')) {\n            setMinMax();\n        }\n    }\n    var x = 0;\n    var y = 0;\n    var scale = 1;\n    var isPanning = false;\n    zoom(options.startScale, { animate: false });\n    // Wait for scale to update\n    // for accurate dimensions\n    // to constrain initial values\n    setTimeout(function () {\n        setMinMax();\n        pan(options.startX, options.startY, { animate: false });\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function trigger(eventName, detail, opts) {\n        if (opts.silent) {\n            return;\n        }\n        var event = new CustomEvent(eventName, { detail: detail });\n        elem.dispatchEvent(event);\n    }\n    function setTransformWithEvent(eventName, opts) {\n        var value = { x: x, y: y, scale: scale };\n        opts.setTransform(elem, value, opts);\n        trigger(eventName, value, opts);\n        trigger('panzoomchange', value, opts);\n        return value;\n    }\n    function setMinMax() {\n        if (options.contain) {\n            var dims = getDimensions(elem);\n            var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;\n            var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;\n            var elemWidth = dims.elem.width / scale;\n            var elemHeight = dims.elem.height / scale;\n            var elemScaledWidth = parentWidth / elemWidth;\n            var elemScaledHeight = parentHeight / elemHeight;\n            if (options.contain === 'inside') {\n                options.maxScale = Math.min(elemScaledWidth, elemScaledHeight);\n            }\n            else if (options.contain === 'outside') {\n                options.minScale = Math.max(elemScaledWidth, elemScaledHeight);\n            }\n        }\n    }\n    function constrainXY(toX, toY, toScale, panOptions) {\n        var opts = __assign(__assign({}, options), panOptions);\n        var result = { x: x, y: y, opts: opts };\n        if (!opts.force && (opts.disablePan || (opts.panOnlyWhenZoomed && scale === opts.startScale))) {\n            return result;\n        }\n        toX = parseFloat(toX);\n        toY = parseFloat(toY);\n        if (!opts.disableXAxis) {\n            result.x = (opts.relative ? x : 0) + toX;\n        }\n        if (!opts.disableYAxis) {\n            result.y = (opts.relative ? y : 0) + toY;\n        }\n        if (opts.contain === 'inside') {\n            var dims = getDimensions(elem);\n            result.x = Math.max(-dims.elem.margin.left - dims.parent.padding.left, Math.min(dims.parent.width -\n                dims.elem.width / toScale -\n                dims.parent.padding.left -\n                dims.elem.margin.left -\n                dims.parent.border.left -\n                dims.parent.border.right, result.x));\n            result.y = Math.max(-dims.elem.margin.top - dims.parent.padding.top, Math.min(dims.parent.height -\n                dims.elem.height / toScale -\n                dims.parent.padding.top -\n                dims.elem.margin.top -\n                dims.parent.border.top -\n                dims.parent.border.bottom, result.y));\n        }\n        else if (opts.contain === 'outside') {\n            var dims = getDimensions(elem);\n            var realWidth = dims.elem.width / scale;\n            var realHeight = dims.elem.height / scale;\n            var scaledWidth = realWidth * toScale;\n            var scaledHeight = realHeight * toScale;\n            var diffHorizontal = (scaledWidth - realWidth) / 2;\n            var diffVertical = (scaledHeight - realHeight) / 2;\n            var minX = (-(scaledWidth - dims.parent.width) -\n                dims.parent.padding.left -\n                dims.parent.border.left -\n                dims.parent.border.right +\n                diffHorizontal) /\n                toScale;\n            var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;\n            result.x = Math.max(Math.min(result.x, maxX), minX);\n            var minY = (-(scaledHeight - dims.parent.height) -\n                dims.parent.padding.top -\n                dims.parent.border.top -\n                dims.parent.border.bottom +\n                diffVertical) /\n                toScale;\n            var maxY = (diffVertical - dims.parent.padding.top) / toScale;\n            result.y = Math.max(Math.min(result.y, maxY), minY);\n        }\n        return result;\n    }\n    function constrainScale(toScale, zoomOptions) {\n        var opts = __assign(__assign({}, options), zoomOptions);\n        var result = { scale: scale, opts: opts };\n        if (!opts.force && opts.disableZoom) {\n            return result;\n        }\n        result.scale = Math.min(Math.max(toScale, opts.minScale), opts.maxScale);\n        return result;\n    }\n    function pan(toX, toY, panOptions) {\n        var result = constrainXY(toX, toY, scale, panOptions);\n        var opts = result.opts;\n        x = result.x;\n        y = result.y;\n        return setTransformWithEvent('panzoompan', opts);\n    }\n    function zoom(toScale, zoomOptions) {\n        var result = constrainScale(toScale, zoomOptions);\n        var opts = result.opts;\n        if (!opts.force && opts.disableZoom) {\n            return;\n        }\n        toScale = result.scale;\n        var toX = x;\n        var toY = y;\n        if (opts.focal) {\n            // The difference between the point after the scale and the point before the scale\n            // plus the current translation after the scale\n            // neutralized to no scale (as the transform scale will apply to the translation)\n            var focal = opts.focal;\n            toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;\n            toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;\n        }\n        var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });\n        x = panResult.x;\n        y = panResult.y;\n        scale = toScale;\n        return setTransformWithEvent('panzoomzoom', opts);\n    }\n    function zoomInOut(isIn, zoomOptions) {\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);\n        return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);\n    }\n    function zoomIn(zoomOptions) {\n        return zoomInOut(true, zoomOptions);\n    }\n    function zoomOut(zoomOptions) {\n        return zoomInOut(false, zoomOptions);\n    }\n    function zoomToPoint(toScale, point, zoomOptions) {\n        var dims = getDimensions(elem);\n        // Instead of thinking of operating on the panzoom element,\n        // think of operating on the area inside the panzoom\n        // element's parent\n        // Subtract padding and border\n        var effectiveArea = {\n            width: dims.parent.width -\n                dims.parent.padding.left -\n                dims.parent.padding.right -\n                dims.parent.border.left -\n                dims.parent.border.right,\n            height: dims.parent.height -\n                dims.parent.padding.top -\n                dims.parent.padding.bottom -\n                dims.parent.border.top -\n                dims.parent.border.bottom\n        };\n        // Adjust the clientX/clientY to ignore the area\n        // outside the effective area\n        var clientX = point.clientX -\n            dims.parent.left -\n            dims.parent.padding.left -\n            dims.parent.border.left -\n            dims.elem.margin.left;\n        var clientY = point.clientY -\n            dims.parent.top -\n            dims.parent.padding.top -\n            dims.parent.border.top -\n            dims.elem.margin.top;\n        // Adjust the clientX/clientY for HTML elements,\n        // because they have a transform-origin of 50% 50%\n        if (!isSVG) {\n            clientX -= dims.elem.width / scale / 2;\n            clientY -= dims.elem.height / scale / 2;\n        }\n        // Convert the mouse point from it's position over the\n        // effective area before the scale to the position\n        // over the effective area after the scale.\n        var focal = {\n            x: (clientX / effectiveArea.width) * (effectiveArea.width * toScale),\n            y: (clientY / effectiveArea.height) * (effectiveArea.height * toScale)\n        };\n        return zoom(toScale, __assign(__assign({}, zoomOptions), { focal: focal, animate: false }));\n    }\n    function zoomWithWheel(event, zoomOptions) {\n        // Need to prevent the default here\n        // or it conflicts with regular page scroll\n        event.preventDefault();\n        var opts = __assign(__assign({}, options), zoomOptions);\n        // Normalize to deltaX in case shift modifier is used on Mac\n        var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;\n        var wheel = delta < 0 ? 1 : -1;\n        var toScale = constrainScale(scale * Math.exp((wheel * opts.step) / 3), opts).scale;\n        return zoomToPoint(toScale, event, opts);\n    }\n    function reset(resetOptions) {\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), resetOptions);\n        scale = constrainScale(opts.startScale, opts).scale;\n        var panResult = constrainXY(opts.startX, opts.startY, scale, opts);\n        x = panResult.x;\n        y = panResult.y;\n        return setTransformWithEvent('panzoomreset', opts);\n    }\n    var origX;\n    var origY;\n    var startClientX;\n    var startClientY;\n    var startScale;\n    var startDistance;\n    var pointers = [];\n    function handleDown(event) {\n        // Don't handle this event if the target is excluded\n        if (event.target &&\n            (event.target.classList.contains(options.excludeClass) ||\n                options.exclude.indexOf(event.target) > -1)) {\n            return;\n        }\n        addPointer(pointers, event);\n        isPanning = true;\n        options.handleStartEvent(event);\n        origX = x;\n        origY = y;\n        trigger('panzoomstart', { x: x, y: y, scale: scale }, options);\n        // This works whether there are multiple\n        // pointers or not\n        var point = getMiddle(pointers);\n        startClientX = point.clientX;\n        startClientY = point.clientY;\n        startScale = scale;\n        startDistance = getDistance(pointers);\n    }\n    function move(event) {\n        if (!isPanning ||\n            origX === undefined ||\n            origY === undefined ||\n            startClientX === undefined ||\n            startClientY === undefined) {\n            return;\n        }\n        addPointer(pointers, event);\n        var current = getMiddle(pointers);\n        if (pointers.length > 1) {\n            // Use the distance between the first 2 pointers\n            // to determine the current scale\n            var diff = getDistance(pointers) - startDistance;\n            var toScale = constrainScale((diff * options.step) / 80 + startScale).scale;\n            zoomToPoint(toScale, current);\n        }\n        pan(origX + (current.clientX - startClientX) / scale, origY + (current.clientY - startClientY) / scale, {\n            animate: false\n        });\n    }\n    function handleUp(event) {\n        // Don't call panzoomend when panning with 2 touches\n        // until both touches end\n        if (pointers.length === 1) {\n            trigger('panzoomend', { x: x, y: y, scale: scale }, options);\n        }\n        // Note: don't remove all pointers\n        // Can restart without having to reinitiate all of them\n        // Remove the pointer regardless of the isPanning state\n        removePointer(pointers, event);\n        if (!isPanning) {\n            return;\n        }\n        isPanning = false;\n        origX = origY = startClientX = startClientY = undefined;\n    }\n    if (!options.disablePan) {\n        onPointer('down', elem, handleDown);\n        onPointer('move', document, move, { passive: true });\n        onPointer('up', document, handleUp, { passive: true });\n    }\n    function destroy() {\n        destroyPointer('down', elem, handleDown);\n        destroyPointer('move', document, move);\n        destroyPointer('up', document, handleUp);\n    }\n    return {\n        destroy: destroy,\n        getPan: function () { return ({ x: x, y: y }); },\n        getScale: function () { return scale; },\n        getOptions: function () { return shallowClone(options); },\n        pan: pan,\n        reset: reset,\n        setOptions: setOptions,\n        setStyle: function (name, value) { return setStyle(elem, name, value); },\n        zoom: zoom,\n        zoomIn: zoomIn,\n        zoomOut: zoomOut,\n        zoomToPoint: zoomToPoint,\n        zoomWithWheel: zoomWithWheel\n    };\n}\nPanzoom.defaultOptions = defaultOptions;\n/* harmony default export */ var panzoom = __webpack_exports__[\"a\"] = (Panzoom);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9pbnRlcnMudHM/ZDA1OCIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLnRzPzA1ZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy50cz84MTQzIiwid2VicGFjazovLy8uL3NyYy9pc0F0dGFjaGVkLnRzP2EwM2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lzU1ZHRWxlbWVudC50cz80NjI4Iiwid2VicGFjazovLy8uL3NyYy9zaGFsbG93Q2xvbmUudHM/ZTQ3NiIsIndlYnBhY2s6Ly8vLi9zcmMvcGFuem9vbS50cz9iOGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0dBRUc7QUFFSCxTQUFTLGNBQWMsQ0FBQyxRQUF3QixFQUFFLEtBQW1CO0lBQ25FLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNO0lBQ3ZCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDVixJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEtBQUssS0FBSyxDQUFDLFNBQVMsRUFBRTtZQUM3QyxPQUFPLENBQUM7U0FDVDtLQUNGO0lBQ0QsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBRU0sU0FBUyxVQUFVLENBQUMsUUFBd0IsRUFBRSxLQUFtQjtJQUN0RSxJQUFJLENBQUM7SUFDTCw0QkFBNEI7SUFDNUIsSUFBSyxLQUFhLENBQUMsT0FBTyxFQUFFO1FBQzFCLENBQUMsR0FBRyxDQUFDO1FBQ0wsS0FBb0IsVUFBc0IsRUFBdEIsS0FBQyxLQUFhLENBQUMsT0FBTyxFQUF0QixjQUFzQixFQUF0QixJQUFzQixFQUFFO1lBQXZDLElBQU0sS0FBSztZQUNkLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFO1lBQ3JCLFVBQVUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDO1NBQzVCO1FBQ0QsT0FBTTtLQUNQO0lBQ0QsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDO0lBQ25DLDRCQUE0QjtJQUM1QixJ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LEVBQXJCLENBQXFCO1FBQ3ZDLEdBQUc7UUFDSCxLQUFLO1FBQ0wsVUFBVTtRQUNWLFFBQVEsRUFBRSxVQUFDLElBQVksRUFBRSxLQUFhLElBQUssZUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQTNCLENBQTJCO1FBQ3RFLElBQUk7UUFDSixNQUFNO1FBQ04sT0FBTztRQUNQLFdBQVc7UUFDWCxhQUFhO0tBQ2Q7QUFDSCxDQUFDO0FBRUQsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjO0FBRXhCLDhFQUFPIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGVzIGZvciB3b3JraW5nIHdpdGggbXVsdGlwbGUgcG9pbnRlciBldmVudHNcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXZlbnRJbmRleChwb2ludGVyczogUG9pbnRlckV2ZW50W10sIGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgbGV0IGkgPSBwb2ludGVycy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSwgZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICBsZXQgaVxuICAvLyBBZGQgdG91Y2hlcyBpZiBhcHBsaWNhYmxlXG4gIGlmICgoZXZlbnQgYXMgYW55KS50b3VjaGVzKSB7XG4gICAgaSA9IDBcbiAgICBmb3IgKGNvbnN0IHRvdWNoIG9mIChldmVudCBhcyBhbnkpLnRvdWNoZXMpIHtcbiAgICAgIHRvdWNoLnBvaW50ZXJJZCA9IGkrK1xuICAgICAgYWRkUG9pbnRlcihwb2ludGVycywgdG91Y2gpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIGkgPSBmaW5kRXZlbnRJbmRleChwb2ludGVycywgZXZlbnQpXG4gIC8vIFVwZGF0ZSBpZiBhbHJlYWR5IHByZXNlbnRcbiAgaWYgKGkgPiAtMSkge1xuICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKVxuICB9XG4gIHBvaW50ZXJzLnB1c2goZXZlbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSwgZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAvLyBBZGQgdG91Y2hlcyBpZiBhcHBsaWNhYmxlXG4gIGlmICgoZXZlbnQgYXMgYW55KS50b3VjaGVzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCB0b3VjaGVzXG4gICAgd2hpbGUgKHBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgcG9pbnRlcnMucG9wKClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgaSA9IGZpbmRFdmVudEluZGV4KHBvaW50ZXJzLCBldmVudClcbiAgaWYgKGkgPiAtMSkge1xuICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKVxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIGNlbnRlciBwb2ludCBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudHMsIGZvciBwYW5uaW5nXG4gKiB3aXRoIG11bHRpcGxlIHBvaW50ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkZGxlKHBvaW50ZXJzOiBQb2ludGVyRXZlbnRbXSkge1xuICAvLyBDb3B5IHRvIGF2b2lkIGNoYW5naW5nIGJ5IHJlZmVyZW5jZVxuICBwb2ludGVycyA9IHBvaW50ZXJzLnNsaWNlKDApXG4gIGxldCBldmVudDE6IFBpY2s8UG9pbnRlckV2ZW50LCAnY2xpZW50WCcgfCAnY2xpZW50WSc+ID0gcG9pbnRlcnMucG9wKClcbiAgbGV0IGV2ZW50MjogUG9pbnRlckV2ZW50XG4gIHdoaWxlICgoZXZlbnQyID0gcG9pbnRlcnMucG9wKCkpKSB7XG4gICAgZXZlbnQxID0ge1xuICAgICAgY2xpZW50WDogKGV2ZW50Mi5jbGllbnRYIC0gZXZlbnQxLmNsaWVudFgpIC8gMiArIGV2ZW50MS5jbGllbnRYLFxuICAgICAgY2xpZW50WTogKGV2ZW50Mi5jbGllbnRZIC0gZXZlbnQxLmNsaWVudFkpIC8gMiArIGV2ZW50MS5jbGllbnRZXG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDFcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIGZvciBwaW5jaCB6b29taW5nLlxuICogTGltaXRzIHRvIHRoZSBmaXJzdCAyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShwb2ludGVyczogUG9pbnRlckV2ZW50W10pIHtcbiAgaWYgKHBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGV2ZW50MSA9IHBvaW50ZXJzWzBdXG4gIGNvbnN0IGV2ZW50MiA9IHBvaW50ZXJzWzFdXG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coTWF0aC5hYnMoZXZlbnQyLmNsaWVudFggLSBldmVudDEuY2xpZW50WCksIDIpICtcbiAgICAgIE1hdGgucG93KE1hdGguYWJzKGV2ZW50Mi5jbGllbnRZIC0gZXZlbnQxLmNsaWVudFkpLCAyKVxuICApXG59XG4iLCJsZXQgZXZlbnRzOiB7IGRvd246IHN0cmluZzsgbW92ZTogc3RyaW5nOyB1cDogc3RyaW5nIH1cbmlmICh0eXBlb2YgKHdpbmRvdyBhcyBhbnkpLlBvaW50ZXJFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICBldmVudHMgPSB7XG4gICAgZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgICBtb3ZlOiAncG9pbnRlcm1vdmUnLFxuICAgIHVwOiAncG9pbnRlcnVwIHBvaW50ZXJsZWF2ZSBwb2ludGVyY2FuY2VsJ1xuICB9XG59IGVsc2UgaWYgKHR5cGVvZiAod2luZG93IGFzIGFueSkuVG91Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICBldmVudHMgPSB7XG4gICAgZG93bjogJ3RvdWNoc3RhcnQnLFxuICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgIHVwOiAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gIH1cbn0gZWxzZSB7XG4gIGV2ZW50cyA9IHtcbiAgICBkb3duOiAnbW91c2Vkb3duJyxcbiAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICB1cDogJ21vdXNldXAgbW91c2VsZWF2ZSdcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25Qb2ludGVyKFxuICBldmVudDogJ2Rvd24nIHwgJ21vdmUnIHwgJ3VwJyxcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGhhbmRsZXI6IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkLFxuICBldmVudE9wdHM/OiBhbnlcbikge1xuICBldmVudHNbZXZlbnRdLnNwbGl0KCcgJykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIDsoZWxlbSBhcyBIVE1MRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcjxcbiAgICAgICdwb2ludGVyZG93bicgfCAncG9pbnRlcm1vdmUnIHwgJ3BvaW50ZXJ1cCcgfCAncG9pbnRlcmxlYXZlJyB8ICdwb2ludGVyY2FuY2VsJ1xuICAgID4obmFtZSBhcyBhbnksIGhhbmRsZXIsIGV2ZW50T3B0cylcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lQb2ludGVyKFxuICBldmVudDogJ2Rvd24nIHwgJ21vdmUnIHwgJ3VwJyxcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgRG9jdW1lbnQsXG4gIGhhbmRsZXI6IChldmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkXG4pIHtcbiAgZXZlbnRzW2V2ZW50XS5zcGxpdCgnICcpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICA7KGVsZW0gYXMgSFRNTEVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXI8XG4gICAgICAncG9pbnRlcmRvd24nIHwgJ3BvaW50ZXJtb3ZlJyB8ICdwb2ludGVydXAnIHwgJ3BvaW50ZXJsZWF2ZScgfCAncG9pbnRlcmNhbmNlbCdcbiAgICA+KG5hbWUgYXMgYW55LCBoYW5kbGVyKVxuICB9KVxufVxuIiwiaW1wb3J0IHsgQ3VycmVudFZhbHVlcywgUGFuem9vbU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIFByb3BlciBwcmVmaXhpbmcgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICovXG5jb25zdCBkaXZTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlXG5jb25zdCBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdtcyddXG5jb25zdCBwcmVmaXhDYWNoZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5mdW5jdGlvbiBnZXRQcmVmaXhlZE5hbWUobmFtZTogc3RyaW5nKSB7XG4gIGlmIChwcmVmaXhDYWNoZVtuYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtuYW1lXVxuICB9XG4gIGlmIChuYW1lIGluIGRpdlN0eWxlKSB7XG4gICAgcmV0dXJuIChwcmVmaXhDYWNoZVtuYW1lXSA9IG5hbWUpXG4gIH1cbiAgY29uc3QgY2FwTmFtZSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSlcbiAgbGV0IGkgPSBwcmVmaXhlcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHByZWZpeGVkTmFtZSA9IGAke3ByZWZpeGVzW2ldfSR7Y2FwTmFtZX1gXG4gICAgaWYgKHByZWZpeGVkTmFtZSBpbiBkaXZTdHlsZSkge1xuICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtuYW1lXSA9IHByZWZpeGVkTmFtZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgc3R5bGUgdmFsdWUgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENTU051bShuYW1lOiBzdHJpbmcsIHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlW2dldFByZWZpeGVkTmFtZShuYW1lKSBhcyBhbnldKSB8fCAwXG59XG5cbmZ1bmN0aW9uIGdldEJveFN0eWxlKFxuICBlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsXG4gIG5hbWU6IHN0cmluZyxcbiAgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVxuKSB7XG4gIC8vIFN1cHBvcnQ6IEZGIDY4K1xuICAvLyBGaXJlZm94IHJlcXVpcmVzIHNwZWNpZmljaXR5IGZvciBib3JkZXJcbiAgY29uc3Qgc3VmZml4ID0gbmFtZSA9PT0gJ2JvcmRlcicgPyAnV2lkdGgnIDogJydcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBnZXRDU1NOdW0oYCR7bmFtZX1MZWZ0JHtzdWZmaXh9YCwgc3R5bGUpLFxuICAgIHJpZ2h0OiBnZXRDU1NOdW0oYCR7bmFtZX1SaWdodCR7c3VmZml4fWAsIHN0eWxlKSxcbiAgICB0b3A6IGdldENTU051bShgJHtuYW1lfVRvcCR7c3VmZml4fWAsIHN0eWxlKSxcbiAgICBib3R0b206IGdldENTU051bShgJHtuYW1lfUJvdHRvbSR7c3VmZml4fWAsIHN0eWxlKVxuICB9XG59XG5cbi8qKlxuICogU2V0IGEgc3R5bGUgdXNpbmcgdGhlIHByb3Blcmx5IHByZWZpeGVkIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFN0eWxlKGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGVsZW0uc3R5bGVbZ2V0UHJlZml4ZWROYW1lKG5hbWUpIGFzIGFueV0gPSB2YWx1ZVxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgdGhlIHRyYW5zaXRpb24gZnJvbSBwYW56b29tIG9wdGlvbnNcbiAqIGFuZCB0YWtlcyBjYXJlIG9mIHByZWZpeGluZyB0aGUgdHJhbnNpdGlvbiBhbmQgdHJhbnNmb3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgb3B0aW9uczogUGFuem9vbU9wdGlvbnMpIHtcbiAgY29uc3QgdHJhbnNpdGlvbiA9IGdldFByZWZpeGVkTmFtZSgndHJhbnNpdGlvbicpXG4gIGNvbnN0IHRyYW5zZm9ybSA9IGdldFByZWZpeGVkTmFtZSgndHJhbnNmb3JtJylcbiAgc2V0U3R5bGUoZWxlbSwgdHJhbnNpdGlvbiwgYCR7dHJhbnNmb3JtfSAke29wdGlvbnMuZHVyYXRpb259bXMgJHtvcHRpb25zLmVhc2luZ31gKVxufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNmb3JtIHVzaW5nIHRoZSBwcm9wZXIgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCxcbiAgeyB4LCB5LCBzY2FsZSB9OiBDdXJyZW50VmFsdWVzLFxuICBvcHRpb25zOiBQYW56b29tT3B0aW9ucyA9IHt9XG4pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGUgPT09ICdib29sZWFuJykge1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIHNldFRyYW5zaXRpb24oZWxlbSwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUoZWxlbSwgJ3RyYW5zaXRpb24nLCAnbm9uZScpXG4gICAgfVxuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgc2V0U3R5bGUoZWxlbSwgJ3RyYW5zZm9ybScsIGBzY2FsZSgke3NjYWxlfSkgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWApXG4gIH0pXG59XG5cbi8qKlxuICogRGltZW5zaW9ucyB1c2VkIGluIGNvbnRhaW5tZW50IGFuZCBmb2NhbCBwb2ludCB6b29taW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCkge1xuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudEVsZW1lbnRcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVxuICBjb25zdCBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudClcbiAgY29uc3QgcmVjdEVsZW0gPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IHJlY3RQYXJlbnQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICByZXR1cm4ge1xuICAgIGVsZW06IHtcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGg6IHJlY3RFbGVtLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0RWxlbS5oZWlnaHQsXG4gICAgICB0b3A6IHJlY3RFbGVtLnRvcCxcbiAgICAgIGJvdHRvbTogcmVjdEVsZW0uYm90dG9tLFxuICAgICAgbGVmdDogcmVjdEVsZW0ubGVmdCxcbiAgICAgIHJpZ2h0OiByZWN0RWxlbS5yaWdodCxcbiAgICAgIG1hcmdpbjogZ2V0Qm94U3R5bGUoZWxlbSwgJ21hcmdpbicsIHN0eWxlKSxcbiAgICAgIGJvcmRlcjogZ2V0Qm94U3R5bGUoZWxlbSwgJ2JvcmRlcicsIHN0eWxlKVxuICAgIH0sXG4gICAgcGFyZW50OiB7XG4gICAgICBzdHlsZTogcGFyZW50U3R5bGUsXG4gICAgICB3aWR0aDogcmVjdFBhcmVudC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdFBhcmVudC5oZWlnaHQsXG4gICAgICB0b3A6IHJlY3RQYXJlbnQudG9wLFxuICAgICAgYm90dG9tOiByZWN0UGFyZW50LmJvdHRvbSxcbiAgICAgIGxlZnQ6IHJlY3RQYXJlbnQubGVmdCxcbiAgICAgIHJpZ2h0OiByZWN0UGFyZW50LnJpZ2h0LFxuICAgICAgcGFkZGluZzogZ2V0Qm94U3R5bGUocGFyZW50LCAncGFkZGluZycsIHBhcmVudFN0eWxlKSxcbiAgICAgIGJvcmRlcjogZ2V0Qm94U3R5bGUocGFyZW50LCAnYm9yZGVyJywgcGFyZW50U3R5bGUpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET01cbiAqIFBhbnpvb20gcmVxdWlyZXMgdGhpcyBzbyBldmVudHMgd29yayBwcm9wZXJseVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F0dGFjaGVkKGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCkge1xuICBjb25zdCBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnRcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnRFbGVtZW50XG4gIHJldHVybiBkb2MgJiYgcGFyZW50ICYmIGRvYy5ub2RlVHlwZSA9PT0gOSAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEgJiYgZG9jLmNvbnRhaW5zKHBhcmVudClcbn1cbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGVsZW1lbnQgaXMgU1ZHIGJ5IGNoZWNraW5nIHRoZSBuYW1lc3BhY2VcbiAqIEV4Y2VwdGlvbjogdGhlIDxzdmc+IGVsZW1lbnQgaXRzZWxmIHNob3VsZCBiZSB0cmVhdGVkIGxpa2UgSFRNTFxuICovXG5jb25zdCByc3ZnID0gL15odHRwOltcXHdcXC5cXC9dK3N2ZyQvXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KSB7XG4gIHJldHVybiByc3ZnLnRlc3QoZWxlbS5uYW1lc3BhY2VVUkkpICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3N2Zydcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmo6IGFueSkge1xuICBjb25zdCBjbG9uZTogYW55ID0ge31cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjbG9uZVtrZXldID0gb2JqW2tleV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG4iLCIvKipcbiAqIFBhbnpvb20gZm9yIHBhbm5pbmcgYW5kIHpvb21pbmcgZWxlbWVudHMgdXNpbmcgQ1NTIHRyYW5zZm9ybXNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1teXdpbC9wYW56b29tXG4gKlxuICogQ29weXJpZ2h0IFRpbW15IFdpbGxpc29uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RpbW15d2lsL3Bhbnpvb20vYmxvYi9tYXN0ZXIvTUlULUxpY2Vuc2UudHh0XG4gKlxuICovXG5pbXBvcnQgJy4vcG9seWZpbGxzJ1xuXG5pbXBvcnQgeyBQYW5PcHRpb25zLCBQYW56b29tRXZlbnQsIFBhbnpvb21PYmplY3QsIFBhbnpvb21PcHRpb25zLCBab29tT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBhZGRQb2ludGVyLCBnZXREaXN0YW5jZSwgZ2V0TWlkZGxlLCByZW1vdmVQb2ludGVyIH0gZnJvbSAnLi9wb2ludGVycydcbmltcG9ydCB7IGRlc3Ryb3lQb2ludGVyLCBvblBvaW50ZXIgfSBmcm9tICcuL2V2ZW50cydcbmltcG9ydCB7IGdldERpbWVuc2lvbnMsIHNldFN0eWxlLCBzZXRUcmFuc2Zvcm0gfSBmcm9tICcuL2NzcydcblxuaW1wb3J0IGlzQXR0YWNoZWQgZnJvbSAnLi9pc0F0dGFjaGVkJ1xuaW1wb3J0IGlzU1ZHRWxlbWVudCBmcm9tICcuL2lzU1ZHRWxlbWVudCdcbmltcG9ydCBzaGFsbG93Q2xvbmUgZnJvbSAnLi9zaGFsbG93Q2xvbmUnXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zOiBQYW56b29tT3B0aW9ucyA9IHtcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIGN1cnNvcjogJ21vdmUnLFxuICBkaXNhYmxlUGFuOiBmYWxzZSxcbiAgZGlzYWJsZVpvb206IGZhbHNlLFxuICBkaXNhYmxlWEF4aXM6IGZhbHNlLFxuICBkaXNhYmxlWUF4aXM6IGZhbHNlLFxuICBkdXJhdGlvbjogMjAwLFxuICBlYXNpbmc6ICdlYXNlLWluLW91dCcsXG4gIGV4Y2x1ZGU6IFtdLFxuICBleGNsdWRlQ2xhc3M6ICdwYW56b29tLWV4Y2x1ZGUnLFxuICBoYW5kbGVTdGFydEV2ZW50OiAoZTogRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gIH0sXG4gIG1heFNjYWxlOiA0LFxuICBtaW5TY2FsZTogMC4xMjUsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFuT25seVdoZW5ab29tZWQ6IGZhbHNlLFxuICByZWxhdGl2ZTogZmFsc2UsXG4gIHNldFRyYW5zZm9ybSxcbiAgc3RhcnRYOiAwLFxuICBzdGFydFk6IDAsXG4gIHN0YXJ0U2NhbGU6IDEsXG4gIHN0ZXA6IDAuM1xufVxuXG5mdW5jdGlvbiBQYW56b29tKFxuICBlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsXG4gIG9wdGlvbnM/OiBPbWl0PFBhbnpvb21PcHRpb25zLCAnZm9yY2UnPlxuKTogUGFuem9vbU9iamVjdCB7XG4gIGlmICghZWxlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFuem9vbSByZXF1aXJlcyBhbiBlbGVtZW50IGFzIGFuIGFyZ3VtZW50JylcbiAgfVxuICBpZiAoZWxlbS5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFuem9vbSByZXF1aXJlcyBhbiBlbGVtZW50IHdpdGggYSBub2RlVHlwZSBvZiAxJylcbiAgfVxuICBpZiAoIWlzQXR0YWNoZWQoZWxlbSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhbnpvb20gc2hvdWxkIGJlIGNhbGxlZCBvbiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBhdHRhY2hlZCB0byB0aGUgRE9NJylcbiAgfVxuXG4gIG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9XG5cbiAgY29uc3QgaXNTVkcgPSBpc1NWR0VsZW1lbnQoZWxlbSlcblxuICAvLyBTZXQgb3ZlcmZsb3cgb24gdGhlIHBhcmVudFxuICBjb25zdCBwYXJlbnQgPSBlbGVtLnBhcmVudEVsZW1lbnRcbiAgcGFyZW50LnN0eWxlLm92ZXJmbG93ID0gb3B0aW9ucy5vdmVyZmxvd1xuICBwYXJlbnQuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJ1xuICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgbW9iaWxlIHRvXG4gIC8vIHByZXZlbnQgc2Nyb2xsaW5nIHdoaWxlIHBhbm5pbmdcbiAgcGFyZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnXG5cbiAgLy8gU2V0IHNvbWUgZGVmYXVsdCBzdHlsZXMgb24gdGhlIHBhbnpvb20gZWxlbWVudFxuICBlbGVtLnN0eWxlLmN1cnNvciA9IG9wdGlvbnMuY3Vyc29yXG4gIGVsZW0uc3R5bGUudXNlclNlbGVjdCA9ICdub25lJ1xuICBlbGVtLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnXG4gIC8vIFRoZSBkZWZhdWx0IGZvciBIVE1MIGlzICc1MCUgNTAlJ1xuICAvLyBUaGUgZGVmYXVsdCBmb3IgU1ZHIGlzICcwIDAnXG4gIC8vIFNWRyBjYW4ndCBiZSBjaGFuZ2VkIGluIElFXG4gIHNldFN0eWxlKFxuICAgIGVsZW0sXG4gICAgJ3RyYW5zZm9ybU9yaWdpbicsXG4gICAgdHlwZW9mIG9wdGlvbnMub3JpZ2luID09PSAnc3RyaW5nJyA/IG9wdGlvbnMub3JpZ2luIDogaXNTVkcgPyAnMCAwJyA6ICc1MCUgNTAlJ1xuICApXG5cbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzOiBPbWl0PFBhbnpvb21PcHRpb25zLCAnZm9yY2UnPiA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0cykge1xuICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSBvcHRzW2tleV1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIG9wdGlvbiBzaWRlLWVmZmVjdHNcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eSgnY3Vyc29yJykpIHtcbiAgICAgIGVsZW0uc3R5bGUuY3Vyc29yID0gb3B0cy5jdXJzb3JcbiAgICB9XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ292ZXJmbG93JykpIHtcbiAgICAgIHBhcmVudC5zdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dcbiAgICB9XG4gICAgaWYgKFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnbWluU2NhbGUnKSB8fFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnbWF4U2NhbGUnKSB8fFxuICAgICAgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnY29udGFpbicpXG4gICAgKSB7XG4gICAgICBzZXRNaW5NYXgoKVxuICAgIH1cbiAgfVxuXG4gIGxldCB4ID0gMFxuICBsZXQgeSA9IDBcbiAgbGV0IHNjYWxlID0gMVxuICBsZXQgaXNQYW5uaW5nID0gZmFsc2VcbiAgem9vbShvcHRpb25zLnN0YXJ0U2NhbGUsIHsgYW5pbWF0ZTogZmFsc2UgfSlcbiAgLy8gV2FpdCBmb3Igc2NhbGUgdG8gdXBkYXRlXG4gIC8vIGZvciBhY2N1cmF0ZSBkaW1lbnNpb25zXG4gIC8vIHRvIGNvbnN0cmFpbiBpbml0aWFsIHZhbHVlc1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzZXRNaW5NYXgoKVxuICAgIHBhbihvcHRpb25zLnN0YXJ0WCwgb3B0aW9ucy5zdGFydFksIHsgYW5pbWF0ZTogZmFsc2UgfSlcbiAgfSlcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50TmFtZTogUGFuem9vbUV2ZW50LCBkZXRhaWw6IGFueSwgb3B0czogUGFuem9vbU9wdGlvbnMpIHtcbiAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsIH0pXG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KGV2ZW50TmFtZTogUGFuem9vbUV2ZW50LCBvcHRzOiBQYW56b29tT3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlID0geyB4LCB5LCBzY2FsZSB9XG4gICAgb3B0cy5zZXRUcmFuc2Zvcm0oZWxlbSwgdmFsdWUsIG9wdHMpXG4gICAgdHJpZ2dlcihldmVudE5hbWUsIHZhbHVlLCBvcHRzKVxuICAgIHRyaWdnZXIoJ3Bhbnpvb21jaGFuZ2UnLCB2YWx1ZSwgb3B0cylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1pbk1heCgpIHtcbiAgICBpZiAob3B0aW9ucy5jb250YWluKSB7XG4gICAgICBjb25zdCBkaW1zID0gZ2V0RGltZW5zaW9ucyhlbGVtKVxuICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBkaW1zLnBhcmVudC53aWR0aCAtIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC0gZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0XG4gICAgICBjb25zdCBwYXJlbnRIZWlnaHQgPSBkaW1zLnBhcmVudC5oZWlnaHQgLSBkaW1zLnBhcmVudC5ib3JkZXIudG9wIC0gZGltcy5wYXJlbnQuYm9yZGVyLmJvdHRvbVxuICAgICAgY29uc3QgZWxlbVdpZHRoID0gZGltcy5lbGVtLndpZHRoIC8gc2NhbGVcbiAgICAgIGNvbnN0IGVsZW1IZWlnaHQgPSBkaW1zLmVsZW0uaGVpZ2h0IC8gc2NhbGVcbiAgICAgIGNvbnN0IGVsZW1TY2FsZWRXaWR0aCA9IHBhcmVudFdpZHRoIC8gZWxlbVdpZHRoXG4gICAgICBjb25zdCBlbGVtU2NhbGVkSGVpZ2h0ID0gcGFyZW50SGVpZ2h0IC8gZWxlbUhlaWdodFxuICAgICAgaWYgKG9wdGlvbnMuY29udGFpbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgb3B0aW9ucy5tYXhTY2FsZSA9IE1hdGgubWluKGVsZW1TY2FsZWRXaWR0aCwgZWxlbVNjYWxlZEhlaWdodClcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb250YWluID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgb3B0aW9ucy5taW5TY2FsZSA9IE1hdGgubWF4KGVsZW1TY2FsZWRXaWR0aCwgZWxlbVNjYWxlZEhlaWdodClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJhaW5YWShcbiAgICB0b1g6IG51bWJlciB8IHN0cmluZyxcbiAgICB0b1k6IG51bWJlciB8IHN0cmluZyxcbiAgICB0b1NjYWxlOiBudW1iZXIsXG4gICAgcGFuT3B0aW9ucz86IFBhbk9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgLi4ucGFuT3B0aW9ucyB9XG4gICAgY29uc3QgcmVzdWx0ID0geyB4LCB5LCBvcHRzIH1cbiAgICBpZiAoIW9wdHMuZm9yY2UgJiYgKG9wdHMuZGlzYWJsZVBhbiB8fCAob3B0cy5wYW5Pbmx5V2hlblpvb21lZCAmJiBzY2FsZSA9PT0gb3B0cy5zdGFydFNjYWxlKSkpIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgdG9YID0gcGFyc2VGbG9hdCh0b1ggYXMgc3RyaW5nKVxuICAgIHRvWSA9IHBhcnNlRmxvYXQodG9ZIGFzIHN0cmluZylcblxuICAgIGlmICghb3B0cy5kaXNhYmxlWEF4aXMpIHtcbiAgICAgIHJlc3VsdC54ID0gKG9wdHMucmVsYXRpdmUgPyB4IDogMCkgKyB0b1hcbiAgICB9XG5cbiAgICBpZiAoIW9wdHMuZGlzYWJsZVlBeGlzKSB7XG4gICAgICByZXN1bHQueSA9IChvcHRzLnJlbGF0aXZlID8geSA6IDApICsgdG9ZXG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY29udGFpbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICByZXN1bHQueCA9IE1hdGgubWF4KFxuICAgICAgICAtZGltcy5lbGVtLm1hcmdpbi5sZWZ0IC0gZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0LFxuICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICBkaW1zLnBhcmVudC53aWR0aCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0ud2lkdGggLyB0b1NjYWxlIC1cbiAgICAgICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcubGVmdCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0ubWFyZ2luLmxlZnQgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0LFxuICAgICAgICAgIHJlc3VsdC54XG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoXG4gICAgICAgIC1kaW1zLmVsZW0ubWFyZ2luLnRvcCAtIGRpbXMucGFyZW50LnBhZGRpbmcudG9wLFxuICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICBkaW1zLnBhcmVudC5oZWlnaHQgLVxuICAgICAgICAgICAgZGltcy5lbGVtLmhlaWdodCAvIHRvU2NhbGUgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgICAgICAgZGltcy5lbGVtLm1hcmdpbi50b3AgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tLFxuICAgICAgICAgIHJlc3VsdC55XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKG9wdHMuY29udGFpbiA9PT0gJ291dHNpZGUnKSB7XG4gICAgICBjb25zdCBkaW1zID0gZ2V0RGltZW5zaW9ucyhlbGVtKVxuICAgICAgY29uc3QgcmVhbFdpZHRoID0gZGltcy5lbGVtLndpZHRoIC8gc2NhbGVcbiAgICAgIGNvbnN0IHJlYWxIZWlnaHQgPSBkaW1zLmVsZW0uaGVpZ2h0IC8gc2NhbGVcbiAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gcmVhbFdpZHRoICogdG9TY2FsZVxuICAgICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gcmVhbEhlaWdodCAqIHRvU2NhbGVcbiAgICAgIGNvbnN0IGRpZmZIb3Jpem9udGFsID0gKHNjYWxlZFdpZHRoIC0gcmVhbFdpZHRoKSAvIDJcbiAgICAgIGNvbnN0IGRpZmZWZXJ0aWNhbCA9IChzY2FsZWRIZWlnaHQgLSByZWFsSGVpZ2h0KSAvIDJcbiAgICAgIGNvbnN0IG1pblggPVxuICAgICAgICAoLShzY2FsZWRXaWR0aCAtIGRpbXMucGFyZW50LndpZHRoKSAtXG4gICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIubGVmdCAtXG4gICAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0ICtcbiAgICAgICAgICBkaWZmSG9yaXpvbnRhbCkgL1xuICAgICAgICB0b1NjYWxlXG4gICAgICBjb25zdCBtYXhYID0gKGRpZmZIb3Jpem9udGFsIC0gZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0KSAvIHRvU2NhbGVcbiAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LngsIG1heFgpLCBtaW5YKVxuICAgICAgY29uc3QgbWluWSA9XG4gICAgICAgICgtKHNjYWxlZEhlaWdodCAtIGRpbXMucGFyZW50LmhlaWdodCkgLVxuICAgICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcudG9wIC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIudG9wIC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tICtcbiAgICAgICAgICBkaWZmVmVydGljYWwpIC9cbiAgICAgICAgdG9TY2FsZVxuICAgICAgY29uc3QgbWF4WSA9IChkaWZmVmVydGljYWwgLSBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCkgLyB0b1NjYWxlXG4gICAgICByZXN1bHQueSA9IE1hdGgubWF4KE1hdGgubWluKHJlc3VsdC55LCBtYXhZKSwgbWluWSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RyYWluU2NhbGUodG9TY2FsZTogbnVtYmVyLCB6b29tT3B0aW9ucz86IFpvb21PcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgLi4uem9vbU9wdGlvbnMgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHsgc2NhbGUsIG9wdHMgfVxuICAgIGlmICghb3B0cy5mb3JjZSAmJiBvcHRzLmRpc2FibGVab29tKSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIHJlc3VsdC5zY2FsZSA9IE1hdGgubWluKE1hdGgubWF4KHRvU2NhbGUsIG9wdHMubWluU2NhbGUpLCBvcHRzLm1heFNjYWxlKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhbih0b1g6IG51bWJlciB8IHN0cmluZywgdG9ZOiBudW1iZXIgfCBzdHJpbmcsIHBhbk9wdGlvbnM/OiBQYW5PcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uc3RyYWluWFkodG9YLCB0b1ksIHNjYWxlLCBwYW5PcHRpb25zKVxuICAgIGNvbnN0IG9wdHMgPSByZXN1bHQub3B0c1xuXG4gICAgeCA9IHJlc3VsdC54XG4gICAgeSA9IHJlc3VsdC55XG5cbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tcGFuJywgb3B0cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb20odG9TY2FsZTogbnVtYmVyLCB6b29tT3B0aW9ucz86IFpvb21PcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uc3RyYWluU2NhbGUodG9TY2FsZSwgem9vbU9wdGlvbnMpXG4gICAgY29uc3Qgb3B0cyA9IHJlc3VsdC5vcHRzXG4gICAgaWYgKCFvcHRzLmZvcmNlICYmIG9wdHMuZGlzYWJsZVpvb20pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0b1NjYWxlID0gcmVzdWx0LnNjYWxlXG4gICAgbGV0IHRvWCA9IHhcbiAgICBsZXQgdG9ZID0geVxuXG4gICAgaWYgKG9wdHMuZm9jYWwpIHtcbiAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvaW50IGFmdGVyIHRoZSBzY2FsZSBhbmQgdGhlIHBvaW50IGJlZm9yZSB0aGUgc2NhbGVcbiAgICAgIC8vIHBsdXMgdGhlIGN1cnJlbnQgdHJhbnNsYXRpb24gYWZ0ZXIgdGhlIHNjYWxlXG4gICAgICAvLyBuZXV0cmFsaXplZCB0byBubyBzY2FsZSAoYXMgdGhlIHRyYW5zZm9ybSBzY2FsZSB3aWxsIGFwcGx5IHRvIHRoZSB0cmFuc2xhdGlvbilcbiAgICAgIGNvbnN0IGZvY2FsID0gb3B0cy5mb2NhbFxuICAgICAgdG9YID0gKGZvY2FsLnggLyB0b1NjYWxlIC0gZm9jYWwueCAvIHNjYWxlICsgeCAqIHRvU2NhbGUpIC8gdG9TY2FsZVxuICAgICAgdG9ZID0gKGZvY2FsLnkgLyB0b1NjYWxlIC0gZm9jYWwueSAvIHNjYWxlICsgeSAqIHRvU2NhbGUpIC8gdG9TY2FsZVxuICAgIH1cbiAgICBjb25zdCBwYW5SZXN1bHQgPSBjb25zdHJhaW5YWSh0b1gsIHRvWSwgdG9TY2FsZSwgeyByZWxhdGl2ZTogZmFsc2UsIGZvcmNlOiB0cnVlIH0pXG4gICAgeCA9IHBhblJlc3VsdC54XG4gICAgeSA9IHBhblJlc3VsdC55XG4gICAgc2NhbGUgPSB0b1NjYWxlXG4gICAgcmV0dXJuIHNldFRyYW5zZm9ybVdpdGhFdmVudCgncGFuem9vbXpvb20nLCBvcHRzKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbUluT3V0KGlzSW46IGJvb2xlYW4sIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCBhbmltYXRlOiB0cnVlLCAuLi56b29tT3B0aW9ucyB9XG4gICAgcmV0dXJuIHpvb20oc2NhbGUgKiBNYXRoLmV4cCgoaXNJbiA/IDEgOiAtMSkgKiBvcHRzLnN0ZXApLCBvcHRzKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbUluKHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICByZXR1cm4gem9vbUluT3V0KHRydWUsIHpvb21PcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbU91dCh6b29tT3B0aW9ucz86IFpvb21PcHRpb25zKSB7XG4gICAgcmV0dXJuIHpvb21Jbk91dChmYWxzZSwgem9vbU9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tVG9Qb2ludChcbiAgICB0b1NjYWxlOiBudW1iZXIsXG4gICAgcG9pbnQ6IHsgY2xpZW50WDogbnVtYmVyOyBjbGllbnRZOiBudW1iZXIgfSxcbiAgICB6b29tT3B0aW9ucz86IFpvb21PcHRpb25zXG4gICkge1xuICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG5cbiAgICAvLyBJbnN0ZWFkIG9mIHRoaW5raW5nIG9mIG9wZXJhdGluZyBvbiB0aGUgcGFuem9vbSBlbGVtZW50LFxuICAgIC8vIHRoaW5rIG9mIG9wZXJhdGluZyBvbiB0aGUgYXJlYSBpbnNpZGUgdGhlIHBhbnpvb21cbiAgICAvLyBlbGVtZW50J3MgcGFyZW50XG4gICAgLy8gU3VidHJhY3QgcGFkZGluZyBhbmQgYm9yZGVyXG4gICAgY29uc3QgZWZmZWN0aXZlQXJlYSA9IHtcbiAgICAgIHdpZHRoOlxuICAgICAgICBkaW1zLnBhcmVudC53aWR0aCAtXG4gICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcubGVmdCAtXG4gICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcucmlnaHQgLVxuICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIubGVmdCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5yaWdodCxcbiAgICAgIGhlaWdodDpcbiAgICAgICAgZGltcy5wYXJlbnQuaGVpZ2h0IC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmJvdHRvbSAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci50b3AgLVxuICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tXG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IHRoZSBjbGllbnRYL2NsaWVudFkgdG8gaWdub3JlIHRoZSBhcmVhXG4gICAgLy8gb3V0c2lkZSB0aGUgZWZmZWN0aXZlIGFyZWFcbiAgICBsZXQgY2xpZW50WCA9XG4gICAgICBwb2ludC5jbGllbnRYIC1cbiAgICAgIGRpbXMucGFyZW50LmxlZnQgLVxuICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgIGRpbXMuZWxlbS5tYXJnaW4ubGVmdFxuICAgIGxldCBjbGllbnRZID1cbiAgICAgIHBvaW50LmNsaWVudFkgLVxuICAgICAgZGltcy5wYXJlbnQudG9wIC1cbiAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcudG9wIC1cbiAgICAgIGRpbXMucGFyZW50LmJvcmRlci50b3AgLVxuICAgICAgZGltcy5lbGVtLm1hcmdpbi50b3BcblxuICAgIC8vIEFkanVzdCB0aGUgY2xpZW50WC9jbGllbnRZIGZvciBIVE1MIGVsZW1lbnRzLFxuICAgIC8vIGJlY2F1c2UgdGhleSBoYXZlIGEgdHJhbnNmb3JtLW9yaWdpbiBvZiA1MCUgNTAlXG4gICAgaWYgKCFpc1NWRykge1xuICAgICAgY2xpZW50WCAtPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZSAvIDJcbiAgICAgIGNsaWVudFkgLT0gZGltcy5lbGVtLmhlaWdodCAvIHNjYWxlIC8gMlxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIG1vdXNlIHBvaW50IGZyb20gaXQncyBwb3NpdGlvbiBvdmVyIHRoZVxuICAgIC8vIGVmZmVjdGl2ZSBhcmVhIGJlZm9yZSB0aGUgc2NhbGUgdG8gdGhlIHBvc2l0aW9uXG4gICAgLy8gb3ZlciB0aGUgZWZmZWN0aXZlIGFyZWEgYWZ0ZXIgdGhlIHNjYWxlLlxuICAgIGNvbnN0IGZvY2FsID0ge1xuICAgICAgeDogKGNsaWVudFggLyBlZmZlY3RpdmVBcmVhLndpZHRoKSAqIChlZmZlY3RpdmVBcmVhLndpZHRoICogdG9TY2FsZSksXG4gICAgICB5OiAoY2xpZW50WSAvIGVmZmVjdGl2ZUFyZWEuaGVpZ2h0KSAqIChlZmZlY3RpdmVBcmVhLmhlaWdodCAqIHRvU2NhbGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHpvb20odG9TY2FsZSwgeyAuLi56b29tT3B0aW9ucywgZm9jYWwsIGFuaW1hdGU6IGZhbHNlIH0pXG4gIH1cblxuICBmdW5jdGlvbiB6b29tV2l0aFdoZWVsKGV2ZW50OiBXaGVlbEV2ZW50LCB6b29tT3B0aW9ucz86IFpvb21PcHRpb25zKSB7XG4gICAgLy8gTmVlZCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGhlcmVcbiAgICAvLyBvciBpdCBjb25mbGljdHMgd2l0aCByZWd1bGFyIHBhZ2Ugc2Nyb2xsXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgLi4uem9vbU9wdGlvbnMgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRvIGRlbHRhWCBpbiBjYXNlIHNoaWZ0IG1vZGlmaWVyIGlzIHVzZWQgb24gTWFjXG4gICAgY29uc3QgZGVsdGEgPSBldmVudC5kZWx0YVkgPT09IDAgJiYgZXZlbnQuZGVsdGFYID8gZXZlbnQuZGVsdGFYIDogZXZlbnQuZGVsdGFZXG4gICAgY29uc3Qgd2hlZWwgPSBkZWx0YSA8IDAgPyAxIDogLTFcbiAgICBjb25zdCB0b1NjYWxlID0gY29uc3RyYWluU2NhbGUoc2NhbGUgKiBNYXRoLmV4cCgod2hlZWwgKiBvcHRzLnN0ZXApIC8gMyksIG9wdHMpLnNjYWxlXG5cbiAgICByZXR1cm4gem9vbVRvUG9pbnQodG9TY2FsZSwgZXZlbnQsIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiByZXNldChyZXNldE9wdGlvbnM/OiBQYW56b29tT3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMsIGFuaW1hdGU6IHRydWUsIC4uLnJlc2V0T3B0aW9ucyB9XG4gICAgc2NhbGUgPSBjb25zdHJhaW5TY2FsZShvcHRzLnN0YXJ0U2NhbGUsIG9wdHMpLnNjYWxlXG4gICAgY29uc3QgcGFuUmVzdWx0ID0gY29uc3RyYWluWFkob3B0cy5zdGFydFgsIG9wdHMuc3RhcnRZLCBzY2FsZSwgb3B0cylcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tcmVzZXQnLCBvcHRzKVxuICB9XG5cbiAgbGV0IG9yaWdYOiBudW1iZXJcbiAgbGV0IG9yaWdZOiBudW1iZXJcbiAgbGV0IHN0YXJ0Q2xpZW50WDogbnVtYmVyXG4gIGxldCBzdGFydENsaWVudFk6IG51bWJlclxuICBsZXQgc3RhcnRTY2FsZTogbnVtYmVyXG4gIGxldCBzdGFydERpc3RhbmNlOiBudW1iZXJcbiAgY29uc3QgcG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdID0gW11cblxuICBmdW5jdGlvbiBoYW5kbGVEb3duKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAvLyBEb24ndCBoYW5kbGUgdGhpcyBldmVudCBpZiB0aGUgdGFyZ2V0IGlzIGV4Y2x1ZGVkXG4gICAgaWYgKFxuICAgICAgZXZlbnQudGFyZ2V0ICYmXG4gICAgICAoKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMob3B0aW9ucy5leGNsdWRlQ2xhc3MpIHx8XG4gICAgICAgIG9wdGlvbnMuZXhjbHVkZS5pbmRleE9mKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KSA+IC0xKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFkZFBvaW50ZXIocG9pbnRlcnMsIGV2ZW50KVxuICAgIGlzUGFubmluZyA9IHRydWVcbiAgICBvcHRpb25zLmhhbmRsZVN0YXJ0RXZlbnQoZXZlbnQpXG4gICAgb3JpZ1ggPSB4XG4gICAgb3JpZ1kgPSB5XG5cbiAgICB0cmlnZ2VyKCdwYW56b29tc3RhcnQnLCB7IHgsIHksIHNjYWxlIH0sIG9wdGlvbnMpXG5cbiAgICAvLyBUaGlzIHdvcmtzIHdoZXRoZXIgdGhlcmUgYXJlIG11bHRpcGxlXG4gICAgLy8gcG9pbnRlcnMgb3Igbm90XG4gICAgY29uc3QgcG9pbnQgPSBnZXRNaWRkbGUocG9pbnRlcnMpXG4gICAgc3RhcnRDbGllbnRYID0gcG9pbnQuY2xpZW50WFxuICAgIHN0YXJ0Q2xpZW50WSA9IHBvaW50LmNsaWVudFlcbiAgICBzdGFydFNjYWxlID0gc2NhbGVcbiAgICBzdGFydERpc3RhbmNlID0gZ2V0RGlzdGFuY2UocG9pbnRlcnMpXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICBpZiAoXG4gICAgICAhaXNQYW5uaW5nIHx8XG4gICAgICBvcmlnWCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBvcmlnWSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBzdGFydENsaWVudFggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgc3RhcnRDbGllbnRZID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhZGRQb2ludGVyKHBvaW50ZXJzLCBldmVudClcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0TWlkZGxlKHBvaW50ZXJzKVxuICAgIGlmIChwb2ludGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBVc2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGZpcnN0IDIgcG9pbnRlcnNcbiAgICAgIC8vIHRvIGRldGVybWluZSB0aGUgY3VycmVudCBzY2FsZVxuICAgICAgY29uc3QgZGlmZiA9IGdldERpc3RhbmNlKHBvaW50ZXJzKSAtIHN0YXJ0RGlzdGFuY2VcbiAgICAgIGNvbnN0IHRvU2NhbGUgPSBjb25zdHJhaW5TY2FsZSgoZGlmZiAqIG9wdGlvbnMuc3RlcCkgLyA4MCArIHN0YXJ0U2NhbGUpLnNjYWxlXG4gICAgICB6b29tVG9Qb2ludCh0b1NjYWxlLCBjdXJyZW50KVxuICAgIH1cblxuICAgIHBhbihcbiAgICAgIG9yaWdYICsgKGN1cnJlbnQuY2xpZW50WCAtIHN0YXJ0Q2xpZW50WCkgLyBzY2FsZSxcbiAgICAgIG9yaWdZICsgKGN1cnJlbnQuY2xpZW50WSAtIHN0YXJ0Q2xpZW50WSkgLyBzY2FsZSxcbiAgICAgIHtcbiAgICAgICAgYW5pbWF0ZTogZmFsc2VcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVVcChldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgLy8gRG9uJ3QgY2FsbCBwYW56b29tZW5kIHdoZW4gcGFubmluZyB3aXRoIDIgdG91Y2hlc1xuICAgIC8vIHVudGlsIGJvdGggdG91Y2hlcyBlbmRcbiAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0cmlnZ2VyKCdwYW56b29tZW5kJywgeyB4LCB5LCBzY2FsZSB9LCBvcHRpb25zKVxuICAgIH1cbiAgICAvLyBOb3RlOiBkb24ndCByZW1vdmUgYWxsIHBvaW50ZXJzXG4gICAgLy8gQ2FuIHJlc3RhcnQgd2l0aG91dCBoYXZpbmcgdG8gcmVpbml0aWF0ZSBhbGwgb2YgdGhlbVxuICAgIC8vIFJlbW92ZSB0aGUgcG9pbnRlciByZWdhcmRsZXNzIG9mIHRoZSBpc1Bhbm5pbmcgc3RhdGVcbiAgICByZW1vdmVQb2ludGVyKHBvaW50ZXJzLCBldmVudClcbiAgICBpZiAoIWlzUGFubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlzUGFubmluZyA9IGZhbHNlXG4gICAgb3JpZ1ggPSBvcmlnWSA9IHN0YXJ0Q2xpZW50WCA9IHN0YXJ0Q2xpZW50WSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFvcHRpb25zLmRpc2FibGVQYW4pIHtcbiAgICBvblBvaW50ZXIoJ2Rvd24nLCBlbGVtLCBoYW5kbGVEb3duKVxuICAgIG9uUG9pbnRlcignbW92ZScsIGRvY3VtZW50LCBtb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgICBvblBvaW50ZXIoJ3VwJywgZG9jdW1lbnQsIGhhbmRsZVVwLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZGVzdHJveVBvaW50ZXIoJ2Rvd24nLCBlbGVtLCBoYW5kbGVEb3duKVxuICAgIGRlc3Ryb3lQb2ludGVyKCdtb3ZlJywgZG9jdW1lbnQsIG1vdmUpXG4gICAgZGVzdHJveVBvaW50ZXIoJ3VwJywgZG9jdW1lbnQsIGhhbmRsZVVwKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95LFxuICAgIGdldFBhbjogKCkgPT4gKHsgeCwgeSB9KSxcbiAgICBnZXRTY2FsZTogKCkgPT4gc2NhbGUsXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gc2hhbGxvd0Nsb25lKG9wdGlvbnMpLFxuICAgIHBhbixcbiAgICByZXNldCxcbiAgICBzZXRPcHRpb25zLFxuICAgIHNldFN0eWxlOiAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzZXRTdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSksXG4gICAgem9vbSxcbiAgICB6b29tSW4sXG4gICAgem9vbU91dCxcbiAgICB6b29tVG9Qb2ludCxcbiAgICB6b29tV2l0aFdoZWVsXG4gIH1cbn1cblxuUGFuem9vbS5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zXG5cbmV4cG9ydCBkZWZhdWx0IFBhbnpvb21cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n"
    )
  },
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_panzoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\nconsole.log('This is a demo version of Panzoom for testing.');\nconsole.log('It exposes a global (window.Panzoom) and should not be used in production.');\nwindow.Panzoom = _src_panzoom__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vL2dsb2JhbC1wYW56b29tLnRzPzdiODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFvQztBQUVwQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdEQUFnRCxDQUFDO0FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsNEVBQTRFLENBQUM7QUFPekYsTUFBTSxDQUFDLE9BQU8sR0FBRyw0REFBTyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhbnpvb20gZnJvbSAnLi4vc3JjL3Bhbnpvb20nXG5cbmNvbnNvbGUubG9nKCdUaGlzIGlzIGEgZGVtbyB2ZXJzaW9uIG9mIFBhbnpvb20gZm9yIHRlc3RpbmcuJylcbmNvbnNvbGUubG9nKCdJdCBleHBvc2VzIGEgZ2xvYmFsICh3aW5kb3cuUGFuem9vbSkgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLicpXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGFuem9vbTogdHlwZW9mIFBhbnpvb21cbiAgfVxufVxud2luZG93LlBhbnpvb20gPSBQYW56b29tXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n"
    )
  },
  function(module, exports) {
    eval(
      "/* eslint-disable no-var */\n// Support: IE11 only\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n// Support: IE11 only\n// CustomEvent is an object instead of a constructor\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzLmpzPzA2NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gU3VwcG9ydDogSUUxMSBvbmx5XG5pZiAod2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG59XG4vLyBTdXBwb3J0OiBJRTExIG9ubHlcbi8vIEN1c3RvbUV2ZW50IGlzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3JcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogbnVsbCB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKVxuICAgIHJldHVybiBldnRcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n"
    )
  }
])
